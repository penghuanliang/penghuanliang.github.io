<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ButterKnife源码分析]]></title>
    <url>%2F2019%2F08%2F07%2FButterKnife%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[又到一年七夕节，祝愿全天下的有情人终成眷属。 一直以来项目中都是使用别人的框架，使用起来很熟练，但是源码一般都是大致粗略的看一下，弄懂整个流程就不去管他了，这段时间我都是在跟源码打交到深有体会，除非知识有一定的沉淀，否则学到的终究只是皮毛。所以打算想要学习的更深入，建议还是多多看源码，不光技术提升，对设计模式、封装思想也会有更深刻的领悟。 本篇文章不涉及如何自定义ButterKnifeAPT插件，如果需要请浏览我写的Demo，效果图如下： 基本的BindView()，以及OnClick()是没有问题的，至于其它的BindColor()原理都是一样 ButterKnife简介ButterKnife是由Android之神JakeWharton开发出来的，通过APT在编译时期获取Java代码中相应的注解并生成对应代码，告别了传统的手动findViewById()，setOnClickListener()等，从而提升代码可读性、开发效率。 ButterKnife工作流程 APT工作流程大致为两步： APT通过扫描解析Java源文件，获取相应的注解，并通过注解生成相应的Java文件。 生成的Java文件后继续编译，APT继续扫描，如果有相应的文件生成则继续重复此步骤。 ButterKnife源码分析 首先看ButterKnifeProcessor 12345678910111213141516171819202122232425262728293031323334353637@AutoService(Processor.class)public final class ButterKnifeProcessor extends AbstractProcessor &#123; //方法注解、监听一些基本事件 private static final List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList( OnCheckedChanged.class, OnClick.class, OnEditorAction.class, OnFocusChange.class, OnItemClick.class, OnItemLongClick.class, OnItemSelected.class, OnLongClick.class, OnPageChange.class, OnTextChanged.class, OnTouch.class ); //...省略 @Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123; //解析注解 Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env); //遍历注解生成java文件 for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123; TypeElement typeElement = entry.getKey(); BindingSet binding = entry.getValue(); JavaFile javaFile = binding.brewJava(sdk, debuggable); try &#123; javaFile.writeTo(filer); &#125; catch (IOException e) &#123; error(typeElement, "Unable to write binding for type %s: %s", typeElement, e.getMessage()); &#125; &#125; return false; &#125;&#125; 接下来我们分析一下findAndParseTargets() 12345678910111213141516171819private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123; Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;(); Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;(); //...省略其它注解 //遍历@BindView,然后将其过滤存储起来 for (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123; try &#123; parseBindView(element, builderMap); &#125; catch (Exception e) &#123; error(element, e.getMessage()); &#125; &#125; // 遍历各种事件,然后将其过滤存储起来 for (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123; findAndParseListener(env, listener, builderMap, erasedTargetNames); &#125; return builderMap; &#125; @分析 BindView#parseBindView()做了什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, Set&lt;TypeElement&gt; erasedTargetNames) &#123; TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); // 这里先做校验，检测@BindView注解是否作用在field属性上,检测是否作用在系统类中的属性上 //下面列出代码 #1 boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, "fields", element) || isBindingInWrongPackage(BindView.class, element); // 校验元素是否作用在View 或者 继承至View的子类上 TypeMirror elementType = element.asType(); if (elementType.getKind() == TypeKind.TYPEVAR) &#123; TypeVariable typeVariable = (TypeVariable) elementType; elementType = typeVariable.getUpperBound(); &#125; Name qualifiedName = enclosingElement.getQualifiedName(); Name simpleName = element.getSimpleName(); if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123; if (elementType.getKind() == TypeKind.ERROR) &#123; note(element, "@%s field with unresolved type (%s) " + "must elsewhere be generated as a View or interface. (%s.%s)", BindView.class.getSimpleName(), elementType, qualifiedName, simpleName); &#125; else &#123; error(element, "@%s fields must extend from View or be an interface. (%s.%s)", BindView.class.getSimpleName(), qualifiedName, simpleName); hasError = true; &#125; &#125; if (hasError) &#123; return; &#125; // 获取属性信息: id 、 name int id = element.getAnnotation(BindView.class).value(); BindingSet.Builder builder = builderMap.get(enclosingElement); //这里画重点,在下面分析 #2 Id resourceId = elementToId(element, BindView.class, id); if (builder != null) &#123; //从集合中获取,如果已经绑定过,则输出error信息 String existingBindingName = builder.findExistingBindingName(resourceId); if (existingBindingName != null) &#123; error(element, "Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)", BindView.class.getSimpleName(), id, existingBindingName, enclosingElement.getQualifiedName(), element.getSimpleName()); return; &#125; &#125; else &#123; //初始化 BindingSet.Builder,并将其放入集合中 builder = getOrCreateBindingBuilder(builderMap, enclosingElement); &#125; String name = simpleName.toString(); TypeName type = TypeName.get(elementType); boolean required = isFieldRequired(element); //将属性添加至BindingSet.Builder中 builder.addField(resourceId, new FieldViewBinding(name, type, required)); // Add the type-erased version to the valid binding targets set. erasedTargetNames.add(enclosingElement); &#125; 这里主要做了三件事情： 校验@BindView作用范围、作用对象是否正确，其次校验是否是作用于View对象获取View的子类对象。 通过创建BindingSet.Builder对象，然后将获取到的注解 id、name 、type 存至该对象。 将BindingSet.Builder存放到相应的集合中。 这里创建BindingSet.Builder对象不仅仅是用于存储某一个注解的单独属性，它存储的是同一个类型所有注解属性、方法，用于后续遍历生成Java文件时写入相关的代码 校验如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//1.这个方法主要是校验修饰符、作用是否在class中、最后再校验class修饰符private boolean isInaccessibleViaGeneratedCode(Class&lt;? extends Annotation&gt; annotationClass, String targetThing, Element element) &#123; boolean hasError = false; //返回当前 类 TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); // 判断field修饰符,如果时private static修饰 抛出异常 Set&lt;Modifier&gt; modifiers = element.getModifiers(); if (modifiers.contains(PRIVATE) || modifiers.contains(STATIC)) &#123; error(element, "@%s %s must not be private or static. (%s.%s)", annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(), element.getSimpleName()); hasError = true; &#125; // 如果不是在class中使用该注解,抛出异常 if (enclosingElement.getKind() != CLASS) &#123; error(enclosingElement, "@%s %s may only be contained in classes. (%s.%s)", annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(), element.getSimpleName()); hasError = true; &#125; // 校验类的修饰符 if (enclosingElement.getModifiers().contains(PRIVATE)) &#123; error(enclosingElement, "@%s %s may not be contained in private classes. (%s.%s)", annotationClass.getSimpleName(), targetThing, enclosingElement.getQualifiedName(), element.getSimpleName()); hasError = true; &#125; return hasError; &#125;//2.这个方法主要是校验class位置是否为系统类 private boolean isBindingInWrongPackage(Class&lt;? extends Annotation&gt; annotationClass, Element element) &#123; TypeElement enclosingElement = (TypeElement) element.getEnclosingElement(); String qualifiedName = enclosingElement.getQualifiedName().toString(); if (qualifiedName.startsWith("android.")) &#123; error(element, "@%s-annotated class incorrectly in Android framework package. (%s)", annotationClass.getSimpleName(), qualifiedName); return true; &#125; if (qualifiedName.startsWith("java.")) &#123; error(element, "@%s-annotated class incorrectly in Java framework package. (%s)", annotationClass.getSimpleName(), qualifiedName); return true; &#125; return false; &#125;//3.校验类型@BindView时这里传入的typeMirror="android.widget.TextView"、otherType="android.view.View"static boolean isSubtypeOfType(TypeMirror typeMirror, String otherType) &#123; //如果两者一致直接 return true if (isTypeEqual(typeMirror, otherType)) &#123; return true; &#125; //如果 typeMirror 不是类/接口 return false if (typeMirror.getKind() != TypeKind.DECLARED) &#123; return false; &#125; //举例: 如果是TextView, declaredType: android.widget.TextView DeclaredType declaredType = (DeclaredType) typeMirror; // typeArguments 这里主要是用于获取泛型中的属性,判断泛型种类型 List&lt;? extends TypeMirror&gt; typeArguments = declaredType.getTypeArguments(); if (typeArguments.size() &gt; 0) &#123; StringBuilder typeString = new StringBuilder(declaredType.asElement().toString()); typeString.append('&lt;'); for (int i = 0; i &lt; typeArguments.size(); i++) &#123; if (i &gt; 0) &#123; typeString.append(','); &#125; typeString.append('?'); &#125; typeString.append('&gt;'); if (typeString.toString().equals(otherType)) &#123; return true; &#125; &#125; Element element = declaredType.asElement(); if (!(element instanceof TypeElement)) &#123; return false; &#125; TypeElement typeElement = (TypeElement) element; //判断父类是否与otherType一致 TypeMirror superType = typeElement.getSuperclass(); if (isSubtypeOfType(superType, otherType)) &#123; return true; &#125; //继承接口判断 for (TypeMirror interfaceType : typeElement.getInterfaces()) &#123; if (isSubtypeOfType(interfaceType, otherType)) &#123; return true; &#125; &#125; return false; &#125; 校验就到这里结束了，主要做了这几个判断： 注解作用对象，作用类，修饰符检测以及判断是否是View类型或继承类型 在BindingSet.Builder构建之前，通过 #elementToId(element, BindView.class, id) 生成了一个Id对象 1234567891011121314151617181920212223242526272829303132333435private Id elementToId(Element element, Class&lt;? extends Annotation&gt; annotation, int value) &#123; //获取给定element的tree节点 //这里的tree = @BindView(value = R.id.tv_first) JCTree tree = (JCTree) trees.getTree(element, getMirror(element, annotation)); if (tree != null) &#123; // tree can be null if the references are compiled types and not source rScanner.reset(); //tree.accept(rScanner) 这里会回调 RScanner中的 visitSelect tree.accept(rScanner); if (!rScanner.resourceIds.isEmpty()) &#123; return rScanner.resourceIds.values().iterator().next(); &#125; &#125; return new Id(value); &#125;private static class RScanner extends TreeScanner &#123; Map&lt;Integer, Id&gt; resourceIds = new LinkedHashMap&lt;&gt;(); @Override public void visitSelect(JCTree.JCFieldAccess jcFieldAccess) &#123; Symbol symbol = jcFieldAccess.sym; if (symbol.getEnclosingElement() != null &amp;&amp; symbol.getEnclosingElement().getEnclosingElement() != null &amp;&amp; symbol.getEnclosingElement().getEnclosingElement().enclClass() != null) &#123; try &#123; int value = (Integer) requireNonNull(((Symbol.VarSymbol) symbol).getConstantValue()); //创建Id并存放至resourceIds集合中 resourceIds.put(value, new Id(value, symbol)); &#125; catch (Exception ignored) &#123; &#125; &#125; &#125; void reset() &#123; resourceIds.clear(); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536private BindingSet.Builder getOrCreateBindingBuilder( Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, TypeElement enclosingElement) &#123; BindingSet.Builder builder = builderMap.get(enclosingElement); if (builder == null) &#123; //构建Builder对象 builder = BindingSet.newBuilder(enclosingElement); builderMap.put(enclosingElement, builder); &#125; return builder; &#125;// BindingSet.Builder#newBuilder(obj),具体构建流程如下，这里obj:com.zl.custombutterknife.MainActivitystatic Builder newBuilder(TypeElement enclosingElement) &#123; //typeMirror:com.zl.custombutterknife.MainActivity | 输入具体的代码看起来更形象 TypeMirror typeMirror = enclosingElement.asType(); //这里 VIEW_TYPE、isSubtypeOfType（）是ButterKnifeProcessor中的 VIEW_TYPE="android.view.View" //区分当前类型是 View、Activity、Dialog boolean isView = isSubtypeOfType(typeMirror, VIEW_TYPE);//这个就是false 了 boolean isActivity = isSubtypeOfType(typeMirror, ACTIVITY_TYPE); //这个就是 true 了 boolean isDialog = isSubtypeOfType(typeMirror, DIALOG_TYPE); // false //这个TypeName是获取 typeMirror一些属性，比如：packageName,simpleName,canonicalName等 TypeName targetType = TypeName.get(typeMirror); if (targetType instanceof ParameterizedTypeName) &#123; targetType = ((ParameterizedTypeName) targetType).rawType; &#125; String packageName = getPackage(enclosingElement).getQualifiedName().toString(); String className = enclosingElement.getQualifiedName().toString().substring( packageName.length() + 1).replace('.', '$'); //创建ClassName: com.zl.custombutterknife.MainActivity_ViewBinding ClassName bindingClassName = ClassName.get(packageName, className + "_ViewBinding"); //final final修饰符 boolean isFinal = enclosingElement.getModifiers().contains(Modifier.FINAL); //Builder构建,这里将注解所在的类，以及将要生成的类信息构建在Builder对象中 return new Builder(targetType, bindingClassName, isFinal, isView, isActivity, isDialog); &#125; Builder对象基本的构建就完成，主要就是将获取注解、注解所在的class构建在一块， 当然这个对象不仅仅只是存储属性，后续的一些listener事件，color、drawable、string等资源需要初始化都将集中在BindingSet对象中 创建 Id对象]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何调试AbstractProcessor]]></title>
    <url>%2F2019%2F08%2F01%2F%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95AbstractProcessor%2F</url>
    <content type="text"><![CDATA[背景由来在自定义ButterKnife时，通过APT方式生成Java代码，因为是编译时期生成，我们无法像Android项目一般运行起来之后通过debug方式来调试，一旦项目无法调试，对于开发者来说是一件很痛苦的事情，下面我们介绍如何 debug 自定义 AbstractProcessor 项目准备阶段 需要配置Gradle环境变量，后期需要通过gradle命令开启守护线程，以及项目构建 开始配置 在AS中点击 Edit Configurations ，如图所示： 创建Remote Debug，如图所示： 第一步： 点击左上角添加按钮，在弹窗中选中remote 第二步：给Remote调试随意取个名字 第三步：设置Host，Port ，一般默认就行，如果有多个请更改端口 第四步：复制刚刚配置的参数，-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 最后点击Ok创建就行 配置gradle.properties文件 123#将刚刚生成的 -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 填入org.gradle.daemon=trueorg.gradle.jvmargs=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 打开命令窗口开启守护线程 12345#开启守护线程$ gradle --daemon#提示build successful 表示开启成功了$ BUILD SUCCESSFUL in 11s$ 1 actionable task: 1 executed 选择刚刚添加的Remote Debug，在项目中打好断点，开启debug模式，如图所示： 点击小虫子后显示：Connected to the target VM, address: ‘localhost:5005’, transport: ‘socket’表示开启成功，如果提示连接不上，请重复上一步骤 最后通过输入gradle命令进行构建 12#定位到相应的项目目录下面构建$gradle clean assembleDebug 这里执行了两个task： task clean ：delete rootProject.buildDir task assembleDebug ：系统封装好的debug构建 task 执行上述命令之后，表示已经成功进入调试了 到这里就结束了，感谢观看。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解笔记]]></title>
    <url>%2F2019%2F08%2F01%2F%E6%B3%A8%E8%A7%A3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[为什么会有本篇文章？ 现在很多主流库都是通过APT(Annotation Processing Tool 简称注解处理工具)在代码编译时期，通过解析注解，并且生成新能Java文件，减少开发者手动书写代码，极大的提升了开发效率。 本篇在学习APT开发时随手记录的，先简单介绍一下注解、然后写一个小Demo加深印象。 Annotation官网描述 The common interface extended by all annotation types. Note that an interface that manually extends this one does not define an annotation type. Also note that this interface does not itself define an annotation type. 大致的意思是：所有的注解类型接口都继承Annotation接口，自定义继承Annotation不会定义注解类型。 个人认为：注解就相当于代码注释一样，然后我们可以通过获取到其属性做一下相关操作，从而优化整个项目。 基本介绍：​ 举例介绍 1234567//本身BindView是一个注解，@Retention@Retention(RetentionPolicy.CLASS)@Target(ElementType.FIELD)public @interface BindView &#123; //可以给定一个默认值 @IdRes int value() default -1;&#125; 继承至Annotation接口的接口，如@BindVeiw、@Retention、@Target都属于注解，但是@Retention、@Target又有区别，它们定义为：元注解 元注解定义：​ 定义在注解上面的注解，我们就称为元注解，它与一般注解的区别就在于Target的作用范围，举例说明 12345678//@Documented 将注解中的元素包含到 Javadoc 中去@Documented@Retention(RetentionPolicy.RUNTIME)//这里作用于ANNOTATION_TYPE，所以@Retention属于元注解@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)public @interface Retention &#123; RetentionPolicy value();&#125; 下面主要介绍@Retention、@Target、@Documented、@Inherited四种常见注解 注解 描述 @Retention 用来定义注解的生命周期，由RetentionPolicy枚举类定义SOURCE:注解在编译器时就会丢弃，不会保留在编译后的class文件中CLASS：注解会保留在class文件中，但是不会加载到JVM中，在运行时候反射是无法获取到相关注解属性RUNTIME:从编译、加载、运行期间会一直保留，可以通过反射的方式获取 @Target 注解的作用域，ElementType枚举类定义CONSTRUCTOR：注解用于 构造函数FIELD：注解用于 成员变量（包括枚举）LOCAL_VARIABLE：注解用于 局部变量METHOD：注解用于 方法PACKAGE：注解用于 包PARAMETER：注解用于 方法中参数TYPE：注解用于 类、接口、枚举类ANNOTATION_TYPE：注解用于 注解，该注解属于元注解 @Documented 表示注解会被包含在Java API文档中 @Inherited 允许子类继承父类的注解 自定义注解 自定义@BindView注解 123456@Retention(RetentionPolicy.CLASS)@Target(&#123;ElementType.FIELD&#125;)public @interface BindView &#123; @IdRes int value() default -1;&#125; 解析注解 通过反射的方式，在运行时期获取 value 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.tv_content) public TextView mTvContent; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Class&lt;? extends MainActivity&gt; clazz = getClass(); try &#123; Field mTvContent = clazz.getField("mTvContent"); //属性字段上是否为@BindView修饰 if (mTvContent.isAnnotationPresent(BindView.class)) &#123; BindView annotation = mTvContent.getAnnotation(BindView.class); //是否是@BindView注解 if (null == annotation) &#123; Log.e("TAG", "未获取到相关注解: "); &#125; else &#123; Log.e("TAG", "annotation value is " + annotation.value() + " mTvContent id is " + R.id.tv_content); &#125; &#125; else &#123; Annotation[] annotations = mTvContent.getAnnotations(); Log.e("TAG", "注解长度: "+annotations.length); if (0==annotations.length) &#123; Log.e("TAG", "未获取到相关注解"); &#125; &#125; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 打印的结果： TAG: 注解长度: 0未获取到相关注解 打印结果没有问题，因为@BindView的生命周期为 CLASS ，注解虽然会保留在class文件中，但是不会加载到JVM中， 所以我们在运行时候反射是无法获取到相关注解属性。 修改BindView之后 1234567//修改为 RUNTIME @Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD&#125;)public @interface BindView &#123; @IdRes int value() default -1;&#125; 打印的结果：TAG: annotation value is 2131165325 mTvContent id is 2131165325 修改了注解的Retention之后，可以正常获取value值，所以注解在使用时多多注意@Target、@Retention使用。 下节介绍注解相关的描述到此就结束了，下一节先介绍如何配置AS,让我们能够debug编译时期代码，然后再介绍通过APT编写自定义ButterKnife。感谢观看。]]></content>
      <categories>
        <category>随手记</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus巧用APT插件提升性能]]></title>
    <url>%2F2019%2F07%2F30%2FEventBus%E5%B7%A7%E7%94%A8APT%E6%8F%92%E4%BB%B6%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[在上一篇研究了EventBus源码时，默认情况下EventBus是通过在运行时反射的方式去获取订阅者中所有@Subscribe注解的方法信息，这种方式是比较损耗性能的。 EventBus是如何提升效率？ 与Butterknife类似，采用编译时注解，在项目编译时将所有的订阅者注解的方法集中到生成class文件中，通过这种方式有效的避免了反射获取注解类的方法信息带来的性能损耗。 基本使用 在项目中集成apt插件 1234567891011121314151617android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; //通过自定义注解处理器生成索引类，如果不配置，类则不生成，下面分析,verbose是否打印日志 arguments = [eventBusIndex : applicationId + '.eventbus.CustomEventBusIndex', verbose : "true"] &#125; &#125; &#125;&#125;dependencies &#123; //加入EventBus implementation 'org.greenrobot:eventbus:3.1.1' //apt加入 annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.1.1'&#125; 先Make Project，apt插件会帮我们生成CustomEventBusIndex 12345678910111213141516171819202122232425262728293031public class CustomEventBusIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; //对象初始化的时候将所有订阅者及注解方法信息统一存储 static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;(); putIndex(new SimpleSubscriberInfo(com.custom.plugin.MainActivity.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo("doSomething", com.custom.plugin.bean.SendBean.class, ThreadMode.MAIN, 100, true), new SubscriberMethodInfo("doBackgroundThing", com.custom.plugin.bean.TBean.class, ThreadMode.MAIN_ORDERED, 100, false), &#125;)); &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; /** * 该方法在SubscriberMethodFinder#findUsingInfo()中调用 */ @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass); if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125;&#125; EventBus自定义初始化 1234567891011121314public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); //通过build方式构建EventBus EventBus.builder() //若为true,则是通过反射方式，默认是false,先从获取eventBusIndex，若为null再通过反射调用 .ignoreGeneratedIndex(false) //自定义添加apt生成的类 .addIndex(new CustomEventBusIndex()) //构建EventBus .installDefaultEventBus(); &#125;&#125; 通过APT插件获取所有订阅者注解信息放入生成class类中，避免运行时反射带来的性能损耗了。 插件源码分析 首先分析EventBusAnnotationProcessor#process () 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 这个注解表示：告知Processor哪些注解需要处理（建议通过复写getSupportedAnnotationTypes() * @SupportedAnnotationTypes()也是一种实现方式，适用于数量较少的情况 */@SupportedAnnotationTypes("org.greenrobot.eventbus.Subscribe")@SupportedOptions(value = &#123;"eventBusIndex", "verbose"&#125;)public class EventBusAnnotationProcessor extends AbstractProcessor &#123; public static final String OPTION_EVENT_BUS_INDEX = "eventBusIndex"; public static final String OPTION_VERBOSE = "verbose"; //...省略：指定java版本、支持的注解类型 /** * 这里扫描、处理注解、生成Java文件 */ @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123; Messager messager = processingEnv.getMessager(); try &#123; //获取 eventBusIndex 配置项，如果没有获取到配置将会打印错误信息，并return false String index = processingEnv.getOptions().get(OPTION_EVENT_BUS_INDEX); if (index == null) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "No option " + OPTION_EVENT_BUS_INDEX +" passed to annotation processor"); return false; &#125; //获取 verbose 配置，是否打印日志 verbose = Boolean.parseBoolean(processingEnv.getOptions().get(OPTION_VERBOSE)); int lastPeriod = index.lastIndexOf('.'); //获取包名 String indexPackage = lastPeriod != -1 ? index.substring(0, lastPeriod) : null; round++; //打印编译时的一些信息 if (verbose) &#123; messager.printMessage(Diagnostic.Kind.NOTE, "Processing round " + round + ", new annotations: " + !annotations.isEmpty() + ", processingOver: " + env.processingOver()); &#125; if (env.processingOver()) &#123; if (!annotations.isEmpty()) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected processing state: annotations still available after processing over"); return false; &#125; &#125; //没有扫描到相关注解直接return if (annotations.isEmpty()) &#123; return false; &#125; //状态异常情况下，直接return if (writerRoundDone) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected processing state: annotations still available after writing."); &#125; //1.添加@Subscribe注解的订阅者及方法，放至集合中 collectSubscribers(annotations, env, messager); //2.过滤掉订阅者 类与方法都是不可见(非public、static修饰)的情况 checkForSubscribersToSkip(messager, indexPackage); if (!methodsByClass.isEmpty()) &#123; //3.生成java文件 createInfoIndexFile(index); &#125; else &#123; messager.printMessage(Diagnostic.Kind.WARNING, "No @Subscribe annotations found"); &#125; writerRoundDone = true; &#125; catch (RuntimeException e) &#123; // IntelliJ does not handle exceptions nicely, so log and print a message e.printStackTrace(); messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected error in EventBusAnnotationProcessor: " + e); &#125; return true; &#125; 主要通过分析添加订阅者，过滤非法订阅者或方法，生成java文件这三个步骤 分析1 collectSubscribers() 1234567891011121314151617181920private void collectSubscribers(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager) &#123; for (TypeElement annotation : annotations) &#123; Set&lt;? extends Element&gt; elements = env.getElementsAnnotatedWith(annotation); for (Element element : elements) &#123; //ExecutableElement类型：表示某个类/接口的方法、构造方法... if (element instanceof ExecutableElement) &#123; ExecutableElement method = (ExecutableElement) element; //方法的Modifier(修饰符)、Parameters(参数)检测 if (checkHasNoErrors(method, messager)) &#123; TypeElement classElement = (TypeElement) method.getEnclosingElement(); //将订阅者及注解方法添加至集合中，后续输出 methodsByClass.putElement(classElement, method); &#125; &#125; else &#123; //注解作用在其它属性上，打印错误信息 messager.printMessage(Diagnostic.Kind.ERROR, "@Subscribe is only valid for methods", element); &#125; &#125; &#125;&#125; checkHasNoErrors() 过滤static、非public、无参的方法 123456789101112131415161718private boolean checkHasNoErrors(ExecutableElement element, Messager messager) &#123; if (element.getModifiers().contains(Modifier.STATIC)) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must not be static", element); return false; &#125; if (!element.getModifiers().contains(Modifier.PUBLIC)) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must be public", element); return false; &#125; List&lt;? extends VariableElement&gt; parameters = ((ExecutableElement) element).getParameters(); if (parameters.size() != 1) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must have exactly 1 parameter", element); return false; &#125; return true;&#125; 分析2 checkForSubscribersToSkip()，如果订阅者 类与方法都是不可见的 添加至过滤classesToSkip集合，后续进行过滤 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private void checkForSubscribersToSkip(Messager messager, String myPackage) &#123; for (TypeElement skipCandidate : methodsByClass.keySet()) &#123; TypeElement subscriberClass = skipCandidate; while (subscriberClass != null) &#123; //过滤订阅者，下面分析isVisible() if (!isVisible(myPackage, subscriberClass)) &#123; boolean added = classesToSkip.add(skipCandidate); if (added) &#123; String msg; if (subscriberClass.equals(skipCandidate)) &#123; msg = "Falling back to reflection because class is not public"; &#125; else &#123; msg = "Falling back to reflection because " + skipCandidate + " has a non-public super class"; &#125; messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass); &#125; break; &#125; //这里是过滤订阅方法 List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberClass); if (methods != null) &#123; for (ExecutableElement method : methods) &#123; String skipReason = null; VariableElement param = method.getParameters().get(0); TypeMirror typeMirror = getParamTypeMirror(param, messager); //判断方法中参数类型是不是class、interface、基本数据类型、java.util.Set&lt;String&gt; //过滤掉非法参数 if (!(typeMirror instanceof DeclaredType) || !(((DeclaredType) typeMirror).asElement() instanceof TypeElement)) &#123; skipReason = "event type cannot be processed"; &#125; //过滤非public、static修饰方法 if (skipReason == null) &#123; TypeElement eventTypeElement = (TypeElement) ((DeclaredType) typeMirror).asElement(); if (!isVisible(myPackage, eventTypeElement)) &#123; skipReason = "event type is not public"; &#125; &#125; //添加至过滤集合 if (skipReason != null) &#123; boolean added = classesToSkip.add(skipCandidate); if (added) &#123; String msg = "Falling back to reflection because " + skipReason; if (!subscriberClass.equals(skipCandidate)) &#123; msg += " (found in super class for " + skipCandidate + ")"; &#125; messager.printMessage(Diagnostic.Kind.NOTE, msg, param); &#125; break; &#125; &#125; &#125; //遍历父类，继续过滤 subscriberClass = getSuperclass(subscriberClass); &#125; &#125;&#125; 上面有一个isVisible()，用于判断元素的修饰符 12345678910111213141516171819private boolean isVisible(String myPackage, TypeElement typeElement) &#123; //返回此元素的修饰符、不包括注解，但包括显式修饰符，比如接口成员的 public 和 static 修饰符 Set&lt;Modifier&gt; modifiers = typeElement.getModifiers(); boolean visible; if (modifiers.contains(Modifier.PUBLIC)) &#123; visible = true; &#125; else if (modifiers.contains(Modifier.PRIVATE) || modifiers.contains(Modifier.PROTECTED)) &#123; visible = false; &#125; else &#123; //包名判断，写入文件时走这里 String subscriberPackage = getPackageElement(typeElement).getQualifiedName().toString(); if (myPackage == null) &#123; visible = subscriberPackage.length() == 0; &#125; else &#123; visible = myPackage.equals(subscriberPackage); &#125; &#125; return visible;&#125; 分析3 createInfoIndex(index)，java文件生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void createInfoIndexFile(String index) &#123; BufferedWriter writer = null; try &#123; //创建我们定义好的路径文件com.xx.xx.eventbus.CustomEventBusIndex.java JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(index); int period = index.lastIndexOf('.'); String myPackage = period &gt; 0 ? index.substring(0, period) : null; String clazz = index.substring(period + 1); writer = new BufferedWriter(sourceFile.openWriter()); //下面就是代码的书写了，包名第一，然后就是导报，在是代码书写 if (myPackage != null) &#123; writer.write("package " + myPackage + ";\n\n"); &#125; writer.write("import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;\n"); writer.write("import org.greenrobot.eventbus.meta.SubscriberMethodInfo;\n"); writer.write("import org.greenrobot.eventbus.meta.SubscriberInfo;\n"); writer.write("import org.greenrobot.eventbus.meta.SubscriberInfoIndex;\n\n"); writer.write("import org.greenrobot.eventbus.ThreadMode;\n\n"); writer.write("import java.util.HashMap;\n"); writer.write("import java.util.Map;\n\n"); writer.write("/** This class is generated by EventBus, do not edit. */\n"); writer.write("public class " + clazz + " implements SubscriberInfoIndex &#123;\n"); writer.write(" private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;\n\n"); writer.write(" static &#123;\n"); writer.write(" SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();\n\n"); //这里就是将上面获取的订阅者及@Subscribe注解方法的集合遍历写入，过滤上述不合适的订阅者及方法 writeIndexLines(writer, myPackage); writer.write(" &#125;\n\n"); writer.write(" private static void putIndex(SubscriberInfo info) &#123;\n"); writer.write(" SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n"); writer.write(" &#125;\n\n"); writer.write(" @Override\n"); writer.write(" public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;\n"); writer.write(" SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n"); writer.write(" if (info != null) &#123;\n"); writer.write(" return info;\n"); writer.write(" &#125; else &#123;\n"); writer.write(" return null;\n"); writer.write(" &#125;\n"); writer.write(" &#125;\n"); writer.write("&#125;\n"); &#125; catch (IOException e) &#123; throw new RuntimeException("Could not write source for " + index, e); &#125; finally &#123; if (writer != null) &#123; try &#123; //关流 刷新 writer.close(); &#125; catch (IOException e) &#123; //Silent &#125; &#125; &#125;&#125; 让我们看看writeIndexLines(writer, myPackage)到底做了什么操作 1234567891011121314151617181920private void writeIndexLines(BufferedWriter writer, String myPackage) throws IOException &#123; for (TypeElement subscriberTypeElement : methodsByClass.keySet()) &#123; //过滤 if (classesToSkip.contains(subscriberTypeElement)) &#123; continue; &#125; //getClassString()主要是参数包名的处理，如com.custom.plugin.MainActivity.class String subscriberClass = getClassString(subscriberTypeElement, myPackage); if (isVisible(myPackage, subscriberTypeElement)) &#123; writeLine(writer, 2, "putIndex(new SimpleSubscriberInfo(" + subscriberClass + ".class,", "true,", "new SubscriberMethodInfo[] &#123;"); List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberTypeElement); writeCreateSubscriberMethods(writer, methods, "new SubscriberMethodInfo", myPackage); writer.write(" &#125;));\n\n"); &#125; else &#123; writer.write(" // Subscriber not visible to index: " + subscriberClass + "\n"); &#125; &#125;&#125; 很明显就是集合的遍历写入，其中包括过滤不合适的订阅者及方法。 到这里EventBusAnnotationProcessor类就分析完成了，接下来打算写一篇自定义ButterKnife文章，深刻学习自定义AbstractProcessor。 感谢观看。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus源码分析]]></title>
    <url>%2F2019%2F07%2F29%2FEventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[EventBus简介EventBus是一种基于Android的事件发布-订阅总线。 EventBus官网描述： simplifies the communication between components decouples event senders and receivers performs well with Activities, Fragments, and background threads avoids complex and error-prone dependencies and life cycle issues makes your code simpler is fast is tiny (~50k jar) is proven in practice by apps with 100,000,000+ installs has advanced features like delivery threads, subscriber priorities, etc. 大致的意思是：EventBus能够简化各个组件之间的通信，解耦了事件发送与接收，让我们的代码更简洁快速，包50KB体积小，支持不同线程切换，具有优先级等特性。 EventBus源码分析从函数构建开始分析： EventBus#getDefault() 1234567891011121314//使用 volatile 关键字 使得线程可见static volatile EventBus defaultInstance;//双重验证加锁单例，确保唯一public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; 事件的订阅： EventBus#getDefault()#register(Object) 123456789101112//订阅事件的入口public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); //内部通过反射方式，获取订阅者事件的方法 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; //接下来就是一些订阅者事件、方法的存储以及如果存在粘性事件将立即发送该粘性事件 subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; 首先分析一下如何获取订阅者方法 1234567891011121314151617181920212223242526//查找订阅者方法List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //从缓存中获取订阅者 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); //不为空则直接返回 if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //若不使用EventBusBuilder自己定义,ignoreGeneratedIndex 默认是 false, if (ignoreGeneratedIndex) &#123; //直接通过放射获取 subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //下面分析 subscriberMethods = findUsingInfo(subscriberClass); &#125; //如果订阅者中不存在@Subscribe注解的方法，则抛出异常 if (subscriberMethods.isEmpty()) &#123; throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation"); &#125; else &#123; //放入缓存池中然后 return 订阅方法 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; findUsingInfo(subscriberClass)，这里有两种情况注意： 12345678910111213141516171819202122232425262728private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; //初始化FindState FindState findState = prepareFindState(); //将subscriberClass赋值 findState.initForSubscriber(subscriberClass); //这里遍历有两种情况 while (findState.clazz != null) &#123; //1.通过APT插件生成的类中获取，避免使用反射，节约性能，这里暂不做分析，下篇研究使用该方式获取 //需要导入apt:annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.1.1' findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; //直接从apt生成的类中获取 SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //2.直接通过反射的方式获取 注解@Subscribe定义的方法，下面继续分析该方法 findUsingReflectionInSingleClass(findState); &#125; //继续遍历父类 findState.moveToSuperclass(); &#125; //通过上面的获取findState中的List&lt;SubscriberMethod&gt;，然后释放findState return getMethodsAndRelease(findState);&#125; 通过反射方式获取 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//直接调用反射获取private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; //通过反射获取所有方法 methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; //异常走这里 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; //开始遍历所有方法 for (Method method : methods) &#123; int modifiers = method.getModifiers(); //方法过滤掉不是public修饰，static,abstract, if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; //获取方法参数 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; //获取@Subscribe注解的方法 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; //校验是否存在同名的方法，如果存在则替换，集合中添加eventType,与method if (findState.checkAdd(method, eventType)) &#123; //获取方法所在的threadMode(线程模型) ThreadMode threadMode = subscribeAnnotation.threadMode(); //将SubscriberMethod存储至findState中 findState.subscriberMethods.add( new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException("@Subscribe method " + methodName + "must have exactly 1 parameter but has " + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException(methodName + " is a illegal @Subscribe method: must be public, non-static, and non-abstract"); &#125; &#125;&#125; 上述基本的获取 @Subscribe 注解分析到此就结束了，下面是分析获取到的method 及 eventType存储及订阅 register()中的遍历集合中的SubscriberMethod，然后调用此方法subscribe()存储及订阅 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; //获取事件类型 Class&lt;?&gt; eventType = subscriberMethod.eventType; //构建 Subscription 便于管理以及事件发送 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //从集合中获取，若不存在，则创建添加 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; //对象已经调用过register(),重复调用,则抛出异常 if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "+ eventType); &#125; &#125; int size = subscriptions.size(); //根据设置的priority向集合中相应的位置进行添加 for (int i = 0; i &lt;= size; i++) &#123; if (i == size||subscriberMethod.priority&gt;subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; //typesBySubscriber用于管理订阅者注销 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); //判断该订阅方法是否为粘性事件，粘性事件发送使用，EventBus.postSticky(obj) if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; //遍历所有的粘性事件 Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; //从stickyEvents集合中获取该事件，进行发送 Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 注意：粘性事件存储在stickyEvents中，如果遍历的时候发现这个订阅方法为粘性，遍历stickyEvents集合，判断如果存在相同的eventType，则立即发送，到这里register()所有的源码分析就结束了。 事件的发送 EventBus通过post(obj)发送事件,期间包括线程的切换等 post 发送事件event 123456789101112131415161718192021222324public void post(Object event) &#123; //获取当前线程中的PostingThreadState状态信息 PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); //event不是发送状态，防止多次调用 if (!postingState.isPosting) &#123; //设置当前线程是否为主线程、发送状态、以及状态判断 postingState.isMainThread = isMainThread(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException("Internal error. Abort state was not reset"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; //发送该事件 postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; postSingleEvent 123456789101112131415161718192021222324252627private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; if (eventInheritance) &#123; //查询所有的父类所包含的event事件对象 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); //将获取到的event、postingState、class对象交付于postSingleEventForEventType()处理 subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; //如果没有找到相应的订阅者 if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; logger.log(Level.FINE, "No subscribers registered for event " + eventClass); &#125; //重置事件，结束事件发送 if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; postSingleEventForEventType 12345678910111213141516171819202122232425262728private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; //从集合中获取 register()存储的 Subscription subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; //发送消息 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125; postToSubscription() 最终调用，通过threadMode进行相应的处理，通过反射、Handler.sendMessage()、提交任务至线程池执行 12345678910111213141516171819202122232425262728293031323334353637383940private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: //直接在调用Post所在的线程中调用该方法 invokeSubscriber(subscription, event); break; case MAIN: //如果post()在主线程直接通过反射调用，否则通过handler的方式进行消息分发处理 if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case MAIN_ORDERED: //Android下一通过handler的方式进行消息分发处理，不管是不是在UI线程 if (mainThreadPoster != null) &#123; mainThreadPoster.enqueue(subscription, event); &#125; else &#123; // HandlerPost创建失败，不在Android环境下直接调用反射 invokeSubscriber(subscription, event); &#125; break; case BACKGROUND: //如果post()在UI线程，则提交至线程池处理 调用run if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; //如果post()在子线程中直接通过反射调用 invokeSubscriber(subscription, event); &#125; break; case ASYNC: //使用ASYNC关键字，不管post()在什么线程中，都交付于线程池去处理 asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125;&#125; EventBus主要是通过维护一个线程池与Handler，在不同的thredMode下进行事件的分发调用，这就所谓的不同threadMode下执行的环境也是不同 线程切换的两个类 HandlerPoster 通过传入UI线程中的looper创建Handler使其在主线程中处理相应的Subscriber方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HandlerPoster extends Handler implements Poster &#123; //省略部分代码。。。。 public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; //此处发送消息 if (!sendMessage(obtainMessage())) &#123; throw new EventBusException("Could not send handler message"); &#125; &#125; &#125; &#125; @Override public void handleMessage(Message msg) &#123; //在这里处理消息 boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); while (true) &#123; //从PendingPostQueue取出PendingPost PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // 双重校验 pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; //此处通过反射调用 eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException("Could not send handler message"); &#125; rescheduled = true; return; &#125; &#125; &#125; finally &#123; handlerActive = rescheduled; &#125; &#125;&#125; BackgroundPoster 用于处理异步任务，通过run()中执行相应事件的调用，所有任务提交至线程池中处理 1234567891011121314151617181920212223242526272829303132333435363738394041final class BackgroundPoster implements Runnable, Poster &#123; //省略部分代码。。。。 public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; queue.enqueue(pendingPost); if (!executorRunning) &#123; executorRunning = true; eventBus.getExecutorService().execute(this); &#125; &#125; &#125; @Override public void run() &#123; try &#123; try &#123; while (true) &#123; PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // 双重校验 pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; //继续调用EventBus.invokeSubscriber(), 在非UI线程中直接通过反射调用@Subscriber方法 eventBus.invokeSubscriber(pendingPost); &#125; &#125; catch (InterruptedException e) &#123; eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + " was interruppted", e); &#125; &#125; finally &#123; executorRunning = false; &#125; &#125;&#125; AsyncPoster与BackgroundPoster类似，都是通过提交run至线程池处理，公用一个线程池 订阅注销操作12345678910111213public synchronized void unregister(Object subscriber) &#123; //register中提到过这个类，专门用户注销订阅者集合 List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); //以下就是遍历，注销操作 if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; typesBySubscriber.remove(subscriber); &#125; else &#123; logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass()); &#125;&#125; 到这里EventBus主要源码分析到此就结束了，感谢收看。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分享]]></title>
    <url>%2F2018%2F09%2F11%2F%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[主题：开心有趣、健康 姓名：彭欢亮 时间：201/9/11 星期二 20:23:12 描述：本文素材均来源于网络，非本人出品 众所周知笑对人体的好处多多，不过小心过犹不及，乐极生悲。微笑又或者是开怀大笑都是有莫大的好处的。 开心一刻 来自小学生试卷： 这位同学对饮食健康很有研究嘛！ 同学你去学画画吧，是块料 我只想知道，你爸爸看过后是什么表情 熊孩子出品 老师居然给98分，逆天了！ 网络大神PS 求大神P个霸气的坐骑： 大神回复： 求大神整个飘逸的发型 求大神把我P成霸气侧漏的样子 求大神把我P出梦幻的感觉 帮我P个好看难忘的背景 麻烦帮我在身下放个女朋友 把跳起来的那家伙去掉 求大神p的更霸气，更帅气 视频分享：大份鸭肉套餐老板只卖12元趣事橘子类的水果，母的比较好吃，那么问题来了怎么区分公母？ 西瓜、苹果、苹果、梨 不要喂狗吃巧克力！ 兔子很少吃胡萝卜！ 鸳鸯的感情专一吗？ 牛其实是色盲！ 不能边吃葡萄边吃海鲜，尤其是吃自助的时候不要忘记！ 健康类（饮食类）它属于“一级至癌物”，发病率高达90%，每家都无视它还在吃！ 禽“尖翅”，其实指的就是鸡、鸭、鹅等禽类屁股上端长尾羽的部位，它其实是个藏污纳垢的“仓库”。不宜食用。 鸡头，鸡越老，鸡头毒性就越大的说法并不十分准确，但是鸡头不宜食用却是事实。医学专家分析，鸡在啄食中会吃进有害的重金属物，鸡头中含有重金属，所以鸡头还是少吃为好。 十年鸡头胜砒霜 煎炸过焦后，产生致癌物质多环芳烃。咖啡烧焦后，苯并芘会增加20倍。油煎饼、臭豆腐、煎炸芋角、油条等，因多数是使用重复多次的油，高温下会产生致癌物。 多环芳烃：是煤，石油，木材，烟草，有机高分子化合物等有机物不完全燃烧时产生的挥发性碳氢化合物，是重要的环境和食品污染物 黄曲霉素主要存在于霉变的坚果、大米和玉米等，吃这些食物时一定要注意清洗和储存得当。 黄曲霉毒素具有很强的致癌性、致突变性和致畸性。 不是所有的肉都是可以吃的,这6种肉千万别贪嘴,有剧毒! 肉类虽然好，但不是什么部位的肉都可以吃的，这6种肉大家千万别贪嘴，有剧毒！ 猪脖子肉： 猪脖子肉上会有圆圆的疙瘩，大概有黄豆大小，呈灰色或者暗红色，这样的肉坚决不能食用，因为这大多数是淋巴结或者未摘除的淋巴腺体！当猪发生疾病时，是疾病转移最明显的地方，藏有大量的毒素和病菌！ 鸡屁股肉： 鸡屁股肉也是不能吃的，但很多人就好这一口，在鸡屁股的后上方有两种腺体，鸡的成千上万个淋巴都集中在这个地方，除了鸡屁股以外，鸡头也是不建议吃的，我国有句民谚：十年鸡头胜砒霜。虽然鸡身上的这两个部位的肉都很好吃，但大家还是别贪嘴！ 虾： 很多人吃虾的时候连同虾头也一并吃掉了，毕竟已经煮熟了，寄生虫啊等坏的物质都已经消失了，其实不然，虾头中含有虾的胃，心脏、肝脏等器官，很多重金属都储存在虾头里，即使煮熟以后，也依然还在！ 鱼腹中的黑膜： 鱼肚子里面的两侧都有一层薄薄的黑色膜衣，很多人都没有注意，直接和鱼肉一同烹饪，一起就吃掉了，其实这层膜衣是腥味，泥土最浓烈的部位，还聚集着一些重金属物质，不建议食用 羊蹄上有羊悬筋： 羊身上也有不能吃的部位，有的羊蹄上有羊“悬筋”， 又称蹄白珠，为圆珠形，串粒状，是羊蹄内发生病变的一种病毒组织。若是误食的话，很容易被感染，我们在吃羊蹄时，一定要看清楚，如果有蹄白珠的话必须摘除。]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>开心一刻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射笔记]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[反射1. 反射定义： JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象. (总结) 反射就是把java类中的各种成分映射成一个个的Java对象 2. 泛型问题系列：（摘自码农每日一题）List 与 List 原始类型之间的区别？ 主要区别有两点。 原始类型和带泛型参数类型 之间的主要区别是在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查，通过使用 Object 作为类型可以告知编译器该方法可以接受任何类型的对象（比如 String 或 Integer）。 我们可以把任何带参数的类型传递给原始类型 List，但却不能把 List 传递给接受 List 的方法，因为会产生编译错误。 简单说说 List 与 List&lt;?&gt; 类型之间的区别？ List 是一个未知类型的 List，而 List 其实是任意类型的 List，我们可以把 List、List 赋值给 List，却不能把 List 赋值给 List。譬如： List&lt;?&gt; listOfAnyType; List&lt;Object&gt; listOfObject = new ArrayList&lt;Object&gt;(); List&lt;String&gt; listOfString = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; listOfInteger = new ArrayList&lt;Integer&gt;(); listOfAnyType = listOfString; //legal listOfAnyType = listOfInteger; //legal listOfObjectType = (List&lt;Object&gt;) listOfString; //compiler error 其他123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346package com.zwang.april;import com.zwang.april.bean.Student;import com.zwang.april.bean.WorkMan;import org.junit.Test;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;/** * ●●● * 反射的概述: * &lt;p&gt; * JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象， * 都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 * 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象. * &lt;p&gt; * (总结) 反射就是把java类中的各种成分映射成一个个的Java对象 * &lt;p&gt; * ●●● * 深拷贝 与 浅拷贝 : 大部分都是浅拷贝（通过实现Cloneable接口，重写clone()方法，调用super.clone()来实现深拷贝） * 真正的深拷贝：通过实现Serializable 接口并用对象的序列化和反序列化来实现真正的深度克隆做法：（参阅下列的 clone()） * 通过ByteArrayOutputStream ObjectArrayOutputStream write() 再通过ByteArrayInputStream ObjectArrayInputStream read()实现 * &lt;p&gt; * ●●● * 泛型的协变 与 逆变 : 协变---&gt; List&lt;? extends Number&gt; list = new ArrayList&lt;&gt;(); 逆变 ---&gt; List&lt;? super Number&gt; list =new ArrayList&lt;&gt;(); * &lt;p&gt; * 泛型的上边界 与 下边界 : ? extends Number 指定了上边界 ? super Number 指定了下边界 * &lt;p&gt; * description: 练习处 * author: phl * date: 2018-04-09 下午 2:06 * update: * version: 1.0 */public class MainActivityTest &#123; /** * 1 获取类名三种方式： * 1.1 通过对象 getClass() * 1.2 通过对象 .class * 1.3 通过包名全路径 Class.forName(String package) */ @Test public void test() &#123; //1.1 获取类名 (创建一个对象实例，然后通过getClass()方法获取---对象都已经拿到了，反射用处不大) Student stu = new Student(); Class&lt;? extends Student&gt; aClass1 = stu.getClass(); System.out.println(aClass1.getName()); //1.2 获取类名 (通过 .class --- 需要导入包，依赖性较强) Class&lt;Student&gt; aClass2 = Student.class; System.out.println(aClass1 == aClass2); try &#123; //1.3 获取类名（通过包名全路径+Class --- 一个字符串就可以，相对于更加优势） Class&lt;?&gt; aClass3 = Class.forName("com.zwang.april.bean.Student"); System.out.println(aClass1 == aClass3); Class&lt;?&gt; aClass = Class.forName("java.util.ArrayList"); System.out.print(aClass.getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 2 通过Class对象获取构造方法，成员变量，成员方法，并访问成员 * &lt;p&gt; * 2.1 通过Class对象获取构造方法 * 批量 * class.getConstructors() 获取该所有public修饰的Constructor * 单个 * class.getConstructor(Class... parameterTypes) 获取指定的public修饰的构造方法 * 批量 * class.getDeclaredConstructors() 获取所有的Constructor * 单个 * class.getDeclaredConstructors(Class... parameterTypes) 获取指定的Constructor */ @Test public void constructor() &#123; try &#123; Class&lt;?&gt; stuClass = Class.forName("com.zwang.april.bean.Student"); Constructor&lt;?&gt;[] pubCons = stuClass.getConstructors(); for (Constructor con : pubCons) &#123; System.out.println(con); &#125; System.out.println("**********************所有构造方法*********************************"); Constructor&lt;?&gt;[] allCons = stuClass.getDeclaredConstructors(); for (Constructor con : allCons) &#123; System.out.println(con); &#125; System.out.println("**********************指定构造方法*********************************"); Constructor&lt;?&gt; constructor = stuClass.getDeclaredConstructor(int.class); System.out.println(constructor); //不能直接访问非public修饰的构造方法、属性或者方法 否则 Framework Method invoke Explosively //暴力访问: setAccessible（true）忽略掉访问修饰符 constructor.setAccessible(true); //Uses the constructor represented by this &#123;@code Constructor&#125; object to //create and initialize a new instance of the constructor's declaring class Object instance = constructor.newInstance(1); System.out.println(instance); &#125; catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; /** * 2.2 访问成员变量并调用 * &lt;p&gt; * 批量 * class.getFields() 访问所有public修饰的字段 * class.getDeclaredFields() 访问所有字段 * &lt;p&gt; * 单个 * class.getField(String name) 访问一个指定public修饰的字段 * class.getDeclaredField(String name) 访问所有的字段 * &lt;p&gt; * 举例：获取某个public修饰的字段 并调用 * (1) Class&lt;?&gt; wClass = Class.forName(); 先获取class对象 * (2) Field f = wClass.getField("name"); 通过getField(String name) 获取public修饰的字段 * (3) Object obj = wClass.getConstructor().newInstance(); 通过构造函数初始化该对象 * (4) f.set(obj,"刘德华"); Field.set(Object obj, Object value); Object ---&gt; 修改字段的对象 value ---&gt; 修改改参数的值(若为private修饰，需要添加访问权限) * (5) WorkMan man = (WorkMan)obj; * (6) 打印man */ @Test public void accessField() &#123; try &#123; Class&lt;?&gt; workClass = Class.forName("com.zwang.april.bean.WorkMan"); System.out.println("****************访问所有public字段****************"); Field[] pubFields = workClass.getFields(); for (Field f : pubFields) &#123; System.out.println(f); &#125; System.out.println("****************访问所有字段（包括private、protect、默认）****************"); Field[] allFields = workClass.getDeclaredFields(); for (Field f : allFields) &#123; System.out.println(f); &#125; Field name = workClass.getDeclaredField("sex"); System.out.println(name); //实例化一个对象 Object obj = workClass.getConstructor().newInstance(); //添加字段访问权限 name.setAccessible(true); //为字段设置值 name.set(obj, '男'); WorkMan workMan = (WorkMan) obj; System.out.println(workMan); &#125; catch (ClassNotFoundException | NoSuchFieldException | IllegalAccessException | InvocationTargetException | InstantiationException | NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125; /** * 2.3 获取成员方法并调用 * 批量 * class.getMethods() * class.getDeclaredMethods() * &lt;p&gt; * 单个 * class.getMethod(String name, Class&lt;?&gt;... parameterTypes) name ---&gt; 方法名 parameterTypes ---&gt;方法中的参数 * class.getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) name ---&gt; 方法名 parameterTypes ---&gt;方法中的参数 * &lt;p&gt; * &lt;p&gt; * 调用方法 * ① Class&lt;?&gt; tClass = Class.forName("com.zwang.april.bean.Teacher"); 获取Class对象 * ② Method method = tClass.getDeclaredMethod("show4",int.class); 获取相应的方法 * ③ Object obj = tClass.getConstructor().newInstance(); 通过构造函数进行实例化，生成Class 对象 * ④ method.setAccessible(true); 私有方法需要添加访问权限 * ⑤ Object objectResult = method.invoke(Object obj, Object... args); obj ---&gt; 实例 ，args ---&gt; 传入相应的参数 * 打印 */ @Test public void accessMethod() &#123; try &#123; Class&lt;?&gt; tClass = Class.forName("com.zwang.april.bean.Teacher"); System.out.println("*****************获取所有public修饰的方法*****************"); Method[] pubMethod = tClass.getMethods(); for (Method m : pubMethod) &#123; System.out.println(m); &#125; System.out.println("*****************获取指定public修饰的方法*****************"); Method show1 = tClass.getMethod("show1", String.class); System.out.println(show1); System.out.println("*****************获取所有方法*****************"); Method[] allMethod = tClass.getDeclaredMethods(); for (Method m : allMethod) &#123; System.out.println(m); &#125; System.out.println("*****************获取指定private修饰的方法*****************"); Method show4 = tClass.getDeclaredMethod("show4", int.class); System.out.println(show4); //调用 Object obj = tClass.getConstructor().newInstance(); //允许访问 show4.setAccessible(true); Object result = show4.invoke(obj, 15); System.out.println(result); &#125; catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; /** * 2.4 反射main方法 * &lt;p&gt; * ┞ Class&lt;?&gt; mClass = Class.forName("com.zwang.april.bean.StaticMethod"); 获取类名 * ┞ Method mMethod = mClass.getMethod("main", String[].class); 获取main() * ┞ 因为是静态方法，所以不需要对象调用，可以直接传入null值 * ┞ mMethod.invoke(null,new Object[]&#123;new String[]&#123;"1","2","3"&#125;&#125;); * ┞ 亦或者传入class * ┞ mMethod.invoke(mClass,new Object[]&#123;new String[]&#123;"1","2","3"&#125;&#125;); */ @Test public void accessMain() &#123; try &#123; Class&lt;?&gt; mClass = Class.forName("com.zwang.april.bean.StaticMethod"); Method mMethod = mClass.getMethod("main", String[].class);// mMethod.invoke(null, (Object) new String[]&#123;"1","2","3"&#125;); //因为是静态方法，所以不需要对象调用，此处可以传null或者是mClass(通过类去调用) // mMethod.invoke(null,new Object[]&#123;new String[]&#123;"1","2","3"&#125;&#125;); mMethod.invoke(mClass, new Object[]&#123;new String[]&#123;"1", "2", "3"&#125;&#125;); &#125; catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; /** * 3.利用反射 、 越过泛型检查 如下 */ @Test public void otherUse() &#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add("aaa"); strList.add("bbb"); Class&lt;ArrayList&gt; listClass = ArrayList.class; try &#123; Method addMethod = listClass.getMethod("add", Object.class); addMethod.invoke(strList, 100); for (Object obj : strList) &#123; System.out.println(obj); &#125; &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; System.out.println("*********************第二种方式***********************"); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("aaa"); list.add("bbb"); ArrayList mList = list; mList.add(100); for (Object obj : mList) &#123; System.out.println(obj); &#125; &#125; /** * 深拷贝 * &lt;p&gt; * 通过实现Serializable接口，并用对象的序列化与反序列化实现真正的深拷贝 */ public &lt;T extends Serializable&gt; T clone(T obj) &#123; T cloneObj = null; try &#123; ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(byteOut); objOut.writeObject(obj); objOut.close(); ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream objInput = new ObjectInputStream(byteInput); cloneObj = (T) objInput.readObject(); objInput.close(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return cloneObj; &#125; /** * 泛型的协变与逆变 * 定义：（≦ 表示继承关系 例如：String extends Object . f(Object) ---&gt; 有Object对象构造出来的一种类型 例如: Object[] 、List） * 当A ≦ B时,如果有f(A) ≦ f(B),那么f叫做协变； * 当A ≦ B时,如果有f(B) ≦ f(A),那么f叫做逆变； * 如果上面两种关系都不成立则叫做不可变。 * &lt;p&gt; * 现在问题来了：究竟什么时候用extends什么时候用super呢？《Effective Java》给出了答案： * PECS: producer-extends, consumer-super. * java.util.Collections的copy方法(JDK1.7)完美地诠释了PECS： */ @Test public void generic() &#123; Object[] objects = new String[3]; //协变 List&lt;? extends Number&gt; list = new ArrayList&lt;&gt;(); //协变 （extends指定泛型的上边界 super指定泛型的下边界） List&lt;? super Number&gt; list1 = new ArrayList&lt;&gt;(); //逆变 &#125;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>反射笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[官网基础]]></title>
    <url>%2F2018%2F01%2F15%2F%E5%AE%98%E7%BD%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[官网基础定义样式要创建一组样式，请在您的项目的 res/values/ 目录中保存一个 XML 文件。 可任意指定该 XML 文件的名称，但它必须使用 .xml 扩展名，并且必须保存在 res/values/ 文件夹内。 该 XML 文件的根节点必须是 &lt;resources&gt;。 对于您想创建的每个样式，向该文件添加一个 &lt;style&gt; 元素，该元素带有对样式进行唯一标识的 name 属性（该属性为必需属性）。然后为该样式的每个属性添加一个 &lt;item&gt; 元素，该元素带有声明样式属性以及属性值的 name（该属性为必需属性）。 根据样式属性，&lt;item&gt; 的值可以是关键字字符串、十六进制颜色值、对另一资源类型的引用或其他值。以下是一个包含单个样式的示例文件： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;style name="CodeFont" parent="@android:style/TextAppearance.Medium"&gt; &lt;item name="android:layout_width"&gt;fill_parent&lt;/item&gt; &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt; &lt;item name="android:typeface"&gt;monospace&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; &lt;resources&gt; 元素的每个子项都会在编译时转换成一个应用资源对象，该对象可由 &lt;style&gt; 元素的 name 属性中的值引用。 可从 XML 布局以 @style/CodeFont 形式引用该示例样式（如上文引言中所示）。 &lt;style&gt; 元素中的 parent 属性是可选属性，它指定应作为此样式所继承属性来源的另一样式的资源 ID。 如果愿意，您可在随后替换这些继承的样式属性。 ​ Fragment向应用栏添加项目您的片段可以通过实现 onCreateOptionsMenu() 向 Activity 的选项菜单（并因此向应用栏）贡献菜单项。不过，为了使此方法能够收到调用，您必须在onCreate() 期间调用 setHasOptionsMenu()，以指示片段想要向选项菜单添加菜单项（否则，片段将不会收到对 onCreateOptionsMenu() 的调用）。 您之后从片段添加到选项菜单的任何菜单项都将追加到现有菜单项之后。 选定菜单项时，片段还会收到对 onOptionsItemSelected() 的回调。 您还可以通过调用 registerForContextMenu()，在片段布局中注册一个视图来提供上下文菜单。用户打开上下文菜单时，片段会收到对onCreateContextMenu() 的调用。当用户选择某个菜单项时，片段会收到对 onContextItemSelected() 的调用。 注：尽管您的片段会收到与其添加的每个菜单项对应的菜单项选定回调，但当用户选择菜单项时，Activity 会首先收到相应的回调。 如果 Activity 对菜单项选定回调的实现不会处理选定的菜单项，则系统会将事件传递到片段的回调。 这适用于选项菜单和上下文菜单。 intent12345678910111213141516171819//验证是否存在接收intent的应用PackageManager packageManager = getPackageManager();List activities = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);boolean isIntentSafe = activities.size() &gt; 0;//添加意图选择Intent intent = new Intent(Intent.ACTION_SEND);...// Always use string resources for UI text.// This says something like "Share this photo with"String title = getResources().getString(R.string.chooser_title);// Create intent to show chooserIntent chooser = Intent.createChooser(intent, title);// Verify the intent will resolve to at least one activityif (intent.resolveActivity(getPackageManager()) != null) &#123; startActivity(chooser);&#125; 12345678910111213141516171819202122232425262728&lt;！--隐式启动--&gt;&lt;activity android:name="ShareActivity"&gt;&lt;!-- filter for sending text; accepts SENDTO action with sms URI schemes --&gt;&lt;intent-filter&gt; &lt;action android:name="android.intent.action.SENDTO"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="sms" /&gt; &lt;data android:scheme="smsto" /&gt;&lt;/intent-filter&gt;&lt;!-- filter for sending text or images; accepts SEND action and text or image data --&gt;&lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="image/*"/&gt; &lt;data android:mimeType="text/plain"/&gt;&lt;/intent-filter&gt;&lt;/activity&gt;// Get the intent that started this activityIntent intent = getIntent();Uri data = intent.getData();// Figure out what to do based on the intent typeif (intent.getType().indexOf("image/") != -1) &#123; // Handle intents with image data ...&#125; else if (intent.getType().equals("text/plain")) &#123; // Handle intents with text ...&#125; 危险权限申请12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Here, thisActivity is the current activityif (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; // Show an expanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission. &#125; else &#123; // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125;//处理回调@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! Do the // contacts-related task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other 'case' lines to check for other // permissions this app might request &#125;&#125; 文件IO12345678910111213141516171819202122232425262728293031323334353637383940//基础写String filename = "myfile";String string = "Hello world!";FileOutputStream outputStream;try &#123; outputStream = openFileOutput(filename, Context.MODE_PRIVATE); outputStream.write(string.getBytes()); outputStream.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125;//临时文件String fileName = Uri.parse(url).getLastPathSegment();file = File.createTempFile(fileName, null, context.getCacheDir());//判断外部存储是否装载public boolean isExternalStorageWritable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) &#123; return true; &#125; return false;&#125;//判断外部存储是否可读public boolean isExternalStorageReadable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123; return true; &#125; return false;&#125; // 指定文件外部存储目录，可以传null. File file = new File(context.getExternalFilesDir( Environment.DIRECTORY_PICTURES), albumName);//查询存储使用信息getCacheDir().getFreeSpace()getCacheDir().getTotalSpace() room数据库的使用：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//By default, Room creates a column for each field that's defined in the entity. //If an entity has fields that you don't want to persist, you can annotate them using @Ignore. //You must reference the entity class through the entities array in the Database class.@Entityclass User &#123; @PrimaryKey public int id; public String firstName; public String lastName; @Ignore Bitmap picture;&#125;//复合型主键@Entity(primaryKeys = &#123;"firstName", "lastName"&#125;)class User &#123; public String firstName; public String lastName; @Ignore Bitmap picture;&#125;//表重命名，否则就是以类名作为表的名字 （注意：表名不区分大小写）@Entity(primaryKeys = &#123;"firstName", "lastName"&#125;)class User &#123; public String firstName; public String lastName; @Ignore Bitmap picture;&#125;//columnInfo 作用与tableName相似，声明的字段会作为表的列明，通过@columnInfo可修改列名@Entity(tableName = "users")class User &#123; @PrimaryKey public int id; @ColumnInfo(name = "first_name") public String firstName; @ColumnInfo(name = "last_name") public String lastName; @Ignore Bitmap picture;&#125;//定义对象之间的关系（）@Entity(foreignKeys = @ForeignKey(entity = User.class, parentColumns = "id", childColumns = "user_id"))class Book &#123; @PrimaryKey public int bookId; public String title; @ColumnInfo(name = "user_id") public int userId;&#125;//使用注解@Embedded创建嵌套对象 （User表中包含Address的street，state,city,post_code）class Address &#123; public String street; public String state; public String city; @ColumnInfo(name = "post_code") public int postCode;&#125;@Entityclass User &#123; @PrimaryKey public int id; public String firstName; @Embedded public Address address;&#125; 相机要求相关硬件12345&lt;manifest ... &gt; &lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt; ...&lt;/manifest&gt; 简单拍照/获取缩略图123456789101112131415161718static final int REQUEST_IMAGE_CAPTURE = 1;//拍照private void dispatchTakePictureIntent() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE); &#125;&#125;//获取缩略图@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get("data"); mImageView.setImageBitmap(imageBitmap); &#125;&#125; 获取唯一文件1234567891011121314151617String mCurrentPhotoPath;private File createImageFile() throws IOException &#123; // Create an image file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()); String imageFileName = "JPEG_" + timeStamp + "_"; File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES); File image = File.createTempFile( imageFileName, /* prefix */ ".jpg", /* suffix */ storageDir /* directory */ ); // Save a file: path for use with ACTION_VIEW intents mCurrentPhotoPath = image.getAbsolutePath(); return image;&#125; 拍照/原图123456789101112131415161718192021222324static final int REQUEST_TAKE_PHOTO = 1;private void dispatchTakePictureIntent() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); // Ensure that there's a camera activity to handle the intent if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; // Create the File where the photo should go File photoFile = null; try &#123; photoFile = createImageFile(); &#125; catch (IOException ex) &#123; // Error occurred while creating the File ... &#125; // Continue only if the File was successfully created if (photoFile != null) &#123; Uri photoURI = FileProvider.getUriForFile(this, "com.example.android.fileprovider", photoFile); takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI); startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO); &#125; &#125;&#125; 通知图库更新12345678//可以让其他应用访问private void galleryAddPic() &#123; Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); File f = new File(mCurrentPhotoPath); Uri contentUri = Uri.fromFile(f); mediaScanIntent.setData(contentUri); this.sendBroadcast(mediaScanIntent);&#125; 尺寸压缩1234567891011121314151617181920212223private void setPic() &#123; // Get the dimensions of the View int targetW = mImageView.getWidth(); int targetH = mImageView.getHeight(); // Get the dimensions of the bitmap BitmapFactory.Options bmOptions = new BitmapFactory.Options(); bmOptions.inJustDecodeBounds = true; BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); int photoW = bmOptions.outWidth; int photoH = bmOptions.outHeight; // Determine how much to scale down the image int scaleFactor = Math.min(photoW/targetW, photoH/targetH); // Decode the image file into a Bitmap sized to fill the View bmOptions.inJustDecodeBounds = false; bmOptions.inSampleSize = scaleFactor; bmOptions.inPurgeable = true; Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); mImageView.setImageBitmap(bitmap);&#125; 调用相机录制视频123456789101112131415161718//添加 &lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt;static final int REQUEST_VIDEO_CAPTURE = 1;private void dispatchTakeVideoIntent() &#123; Intent takeVideoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE); if (takeVideoIntent.resolveActivity(getPackageManager()) != null) &#123; startActivityForResult(takeVideoIntent, REQUEST_VIDEO_CAPTURE); &#125;&#125;//通过使用videoView播放@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent intent) &#123; if (requestCode == REQUEST_VIDEO_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Uri videoUri = intent.getData(); mVideoView.setVideoURI(videoUri); &#125;&#125; Sence布局生成Sence12345678910Scene mAScene;Scene mAnotherScene;// Create the scene root for the scenes in this appmSceneRoot = (ViewGroup) findViewById(R.id.scene_root);// Create the scenesmAScene = Scene.getSceneForLayout(mSceneRoot, R.layout.a_scene, this);mAnotherScene = Scene.getSceneForLayout(mSceneRoot, R.layout.another_scene, this); 代码创建Sence1234567891011Scene mScene;// Obtain the scene root elementmSceneRoot = (ViewGroup) mSomeLayoutElement;// Obtain the view hierarchy to add as a child of// the scene root when this scene is enteredmViewHierarchy = (ViewGroup) someOtherLayoutElement;// Create a scenemScene = new Scene(mSceneRoot, mViewHierarchy); Transition的创建12345678910//通过布局的方式创建//res/transition/fade_transition.xml&lt;fade xmlns:android="http://schemas.android.com/apk/res/android" /&gt;Transition mFadeTransition = TransitionInflater.from(this). inflateTransition(R.transition.fade_transition);//通过代码的方式创建Transition [AutoTransition,Fade,ChangeBounds]Transition mFadeTransition = new Fade(); Transition应用有场景的转换12//通常用于不同的视图切换TransitionManager.go(mEndingScene, mFadeTransition); Transition应用无场景的转换(TransitionManager.beginDelayedTransition(rootview,flag) 用于记录视图层次结构)123456789101112// Get the root view and create a transitionmRootView = (ViewGroup) findViewById(R.id.mainLayout);mFade = new Fade(IN);// Start recording changes to the view hierarchyTransitionManager.beginDelayedTransition(mRootView, mFade);// Add the new TextView to the view hierarchymRootView.addView(mLabelText);// When the system redraws the screen to show this update,// the framework will animate the addition as a fade in PageTransformer缩放效果（https://developer.android.google.cn/training/animation/anim_page_transformer_zoomout.mp4） 1234567891011121314151617181920212223242526272829303132333435363738public class ZoomOutPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 透明效果（https://developer.android.google.cn/training/animation/anim_page_transformer_depth.mp4） 123456789101112131415161718192021222324252627282930313233343536public class DepthPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 0) &#123; // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 查看大图(https://developer.android.google.cn/training/animation/anim_zoom.mp4)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137private void zoomImageFromThumb(final View thumbView, int imageResId) &#123; // If there's an animation in progress, cancel it // immediately and proceed with this one. if (mCurrentAnimator != null) &#123; mCurrentAnimator.cancel(); &#125; // Load the high-resolution "zoomed-in" image. final ImageView expandedImageView = (ImageView) findViewById( R.id.expanded_image); expandedImageView.setImageResource(imageResId); // Calculate the starting and ending bounds for the zoomed-in image. // This step involves lots of math. Yay, math. final Rect startBounds = new Rect(); final Rect finalBounds = new Rect(); final Point globalOffset = new Point(); // The start bounds are the global visible rectangle of the thumbnail, // and the final bounds are the global visible rectangle of the container // view. Also set the container view's offset as the origin for the // bounds, since that's the origin for the positioning animation // properties (X, Y). thumbView.getGlobalVisibleRect(startBounds); findViewById(R.id.container) .getGlobalVisibleRect(finalBounds, globalOffset); startBounds.offset(-globalOffset.x, -globalOffset.y); finalBounds.offset(-globalOffset.x, -globalOffset.y); // Adjust the start bounds to be the same aspect ratio as the final // bounds using the "center crop" technique. This prevents undesirable // stretching during the animation. Also calculate the start scaling // factor (the end scaling factor is always 1.0). float startScale; if ((float) finalBounds.width() / finalBounds.height() &gt; (float) startBounds.width() / startBounds.height()) &#123; // Extend start bounds horizontally startScale = (float) startBounds.height() / finalBounds.height(); float startWidth = startScale * finalBounds.width(); float deltaWidth = (startWidth - startBounds.width()) / 2; startBounds.left -= deltaWidth; startBounds.right += deltaWidth; &#125; else &#123; // Extend start bounds vertically startScale = (float) startBounds.width() / finalBounds.width(); float startHeight = startScale * finalBounds.height(); float deltaHeight = (startHeight - startBounds.height()) / 2; startBounds.top -= deltaHeight; startBounds.bottom += deltaHeight; &#125; // Hide the thumbnail and show the zoomed-in view. When the animation // begins, it will position the zoomed-in view in the place of the // thumbnail. thumbView.setAlpha(0f); expandedImageView.setVisibility(View.VISIBLE); // Set the pivot point for SCALE_X and SCALE_Y transformations // to the top-left corner of the zoomed-in view (the default // is the center of the view). expandedImageView.setPivotX(0f); expandedImageView.setPivotY(0f); // Construct and run the parallel animation of the four translation and // scale properties (X, Y, SCALE_X, and SCALE_Y). AnimatorSet set = new AnimatorSet(); set .play(ObjectAnimator.ofFloat(expandedImageView, View.X, startBounds.left, finalBounds.left)) .with(ObjectAnimator.ofFloat(expandedImageView, View.Y, startBounds.top, finalBounds.top)) .with(ObjectAnimator.ofFloat(expandedImageView, View.SCALE_X, startScale, 1f)).with(ObjectAnimator.ofFloat(expandedImageView, View.SCALE_Y, startScale, 1f)); set.setDuration(mShortAnimationDuration); set.setInterpolator(new DecelerateInterpolator()); set.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; mCurrentAnimator = null; &#125; @Override public void onAnimationCancel(Animator animation) &#123; mCurrentAnimator = null; &#125; &#125;); set.start(); mCurrentAnimator = set; // Upon clicking the zoomed-in image, it should zoom back down // to the original bounds and show the thumbnail instead of // the expanded image. final float startScaleFinal = startScale; expandedImageView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (mCurrentAnimator != null) &#123; mCurrentAnimator.cancel(); &#125; // Animate the four positioning/sizing properties in parallel, // back to their original values. AnimatorSet set = new AnimatorSet(); set.play(ObjectAnimator .ofFloat(expandedImageView, View.X, startBounds.left)) .with(ObjectAnimator .ofFloat(expandedImageView, View.Y,startBounds.top)) .with(ObjectAnimator .ofFloat(expandedImageView, View.SCALE_X, startScaleFinal)) .with(ObjectAnimator .ofFloat(expandedImageView, View.SCALE_Y, startScaleFinal)); set.setDuration(mShortAnimationDuration); set.setInterpolator(new DecelerateInterpolator()); set.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; thumbView.setAlpha(1f); expandedImageView.setVisibility(View.GONE); mCurrentAnimator = null; &#125; @Override public void onAnimationCancel(Animator animation) &#123; thumbView.setAlpha(1f); expandedImageView.setVisibility(View.GONE); mCurrentAnimator = null; &#125; &#125;); set.start(); mCurrentAnimator = set; &#125; &#125;);&#125; 更改布局动画（添加、删除、更新）12345&lt;!--在相应的布局中添加animateLayoutChanges = true--&gt;&lt;LinearLayout android:id="@+id/container" android:animateLayoutChanges="true" .../&gt; 尺寸限定符：res/layout/main.xml，单窗格（默认）布局： res/layout-large/main.xml，双窗格布局： res/layout-sw600dp/main.xml，双窗格布局：（最小宽度大于或等于 600dp 的设备将选择 layout-sw600dp/main.xml） NinePatch(.9图制作详情) 边框沿线的黑色像素。顶部和左侧边框上的黑色像素指示可以拉伸图像的位置，右侧和底部边框上的黑色像素则指示应该放置内容的位置。 DP xhdpi：2.0 hdpi：1.5 mdpi：1.0（基准） ldpi：0.75 ConstraintLayout 官网有详细介绍 https://developer.android.google.cn/training/constraint-layout/index.html Toolbar12345678&lt;android.support.v7.widget.Toolbar android:id="@+id/my_toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:elevation="4dp" 官方推荐 android:theme="@style/ThemeOverlay.AppCompat.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; SearchView 可以作为menu使用，也可以作为一个控件使用 12345&lt;item android:id="@+id/action_search" android:title="@string/action_search" android:icon="@drawable/ic_search" app:showAsAction="ifRoom|collapseActionView" app:actionViewClass="android.support.v7.widget.SearchView" /&gt; 1234567891011121314151617@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main_activity_actions, menu); MenuItem searchItem = menu.findItem(R.id.action_search); SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem); // Configure the search info and add any event listeners... return super.onCreateOptionsMenu(menu);&#125;//可以自定义各种状态下的iconactionView.setOnCloseListener();//监听打开关闭actionView.setOnSuggestionListener();//推荐列表 actionView.setOnQueryTextListener()//类似文本间监听 返回false自动收起键盘 snackbar1234Snackbar mySnackbar = Snackbar.make(findViewById(R.id.myCoordinatorLayout), R.string.email_archived,Snackbar.LENGTH_SHORT);mySnackbar.setAction(R.string.undo_string, new MyUndoListener());mySnackbar.show(); 管理系统界面123456789// This example uses decor view, but you can use any visible view.View decorView = getActivity().getWindow().getDecorView();int uiOptions = View.SYSTEM_UI_FLAG_LOW_PROFILE;decorView.setSystemUiVisibility(uiOptions);View decorView = getActivity().getWindow().getDecorView();// Calling setSystemUiVisibility() with a value of 0 clears// all flags.decorView.setSystemUiVisibility(0); 隐藏状态栏当失去焦点时会无效，比如触摸其他，后台重新进入界面 12345678910111213141516171819202122232425262728293031323334353637383940View decorView = getWindow().getDecorView();// Hide the status bar.int uiOptions = View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(uiOptions);// Remember that you should never show the action bar if the// status bar is hidden, so hide that too if necessary.ActionBar actionBar = getActionBar();actionBar.hide();//配合setFitsSystemWindows()View.SYSTEM_UI_FLAG_FULLSCREEN | //隐藏状态栏View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN| //内容填充状态栏View.SYSTEM_UI_FLAG_LAYOUT_STABLE| //保持布局稳定View.SYSTEM_UI_FLAG_HIDE_NAVIGATION|//隐藏导航虚拟按键View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION|//内容填充导航虚拟按键View.SYSTEM_UI_FLAG_IMMERSIVE|//沉浸式全屏View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY//沉浸式全屏 划出状态栏，状态栏会自动消失//处理状态栏被显示的问题getWindow().getDecorView().setOnSystemUiVisibilityChangeListeneronWindowFocusChanged() mDecorView.setOnSystemUiVisibilityChangeListener(new View.OnSystemUiVisibilityChangeListener() &#123; @Override public void onSystemUiVisibilityChange(int visibility) &#123; // Note that system bars will only be "visible" if none of the // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set. if ((visibility &amp; View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) &#123; // TODO: The system bars are visible. Make any desired // adjustments to your UI, such as showing the action bar or // other navigational controls. &#125; else &#123; // TODO: The system bars are NOT visible. Make any desired // adjustments to your UI, such as hiding the action bar or // other navigational controls. &#125; &#125; &#125;); Material Design定制状态栏 12//当recycleview宽高不变时增删改查时提高性能mRecyclerView.setHasFixedSize(true); 阴影 12345Z = elevation + translationZ//自定义阴影轮廓，因为实际轮廓都是正方形扩展 ViewOutlineProvider 类别。替代 getOutline() 方法。利用 View.setOutlineProvider() 方法向您的视图指定新的轮廓提供程序。 定制动画触摸反馈（水波纹）12345//矩形边框水波纹android:background="?android:attr/selectableItemBackground"//无边框限制水波纹android:background="?android:attr/selectableItemBackgroundBorderless" 自定义水波纹12345678910111213141516171819/*** Creates a new ripple drawable with the specified ripple color and * optional content and mask drawables. * 通过指定波纹的颜色、操作内容、蒙板边界 创建新的ripple drawable 。 * @param color The ripple color 波纹颜色 * @param content The content drawable, may be &#123;@code null&#125; 指定content drawable * @param mask The mask drawable, may be &#123;@code null&#125; 蒙板边界 、为null时，无边界 */public RippleDrawable(@NonNull ColorStateList color, @Nullable Drawable content, @Nullable Drawable mask) &#123; ...&#125;RippleDrawable rd = new RippleDrawable( ColorStateList.valueOf( getResources().getColor(R.color.bg_gray)), drawable, getShape() );tvColor.setBackgroundDrawable(rd); 揭露动画123// create the animator for this view (the start radius is zero)Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0, finalRadius); ​]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>官网基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画]]></title>
    <url>%2F2018%2F01%2F07%2F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[动画笔记 作者：彭欢亮 时间：2018/1/7 星期日 上午 10:10:10 Android 动画的分类 ： 一、帧动画 实现帧动画的两种方式 利用xml形式实现 在drawable目录下创建一个animation-list xml 文件， 1234567891011121314 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;item android:drawable="@mipmap/ic_setup" android:duration="500" /&gt;&lt;item android:drawable="@mipmap/ic_should_get" android:duration="500" /&gt;&lt;item android:drawable="@mipmap/ic_should_pay" android:duration="500" /&gt;&lt;/animation-list&gt; MainActivity代码 123456ImageView imageView = (ImageView) findViewById(R.id.iv);imageView.setImageResource(R.drawable.animation_z);AnimationDrawable animation = (AnimationDrawable) imageView.getDrawable();// animation.start();//将animationDrawable设置为imageView的背景imageView.setBackground(animation); 帧动画实现的第二种方式，利用代码实现 （使用场景：帧动画图片太多的情况下，建议使用此方法，不用在xml文件中一个个添加） MainActivity 123456789101112ImageView imageView = (ImageView) findViewById(R.id.iv)AnimationDrawable anim = new AnimationDrawable();anim.addFrame(bit2dra(R.mipmap.ic_setup), 200);anim.addFrame(bit2dra(R.mipmap.ic_should_get), 200);anim.addFrame(bit2dra(R.mipmap.ic_should_pay), 200);anim.setOneShot(false);imageView.setImageDrawable(anim);//bit2dra 将bitmap转换为drawable对象private Drawable bit2dra(int sourceId) &#123; return new BitmapDrawable(getResources(), BitmapFactory.decodeResource(getResources(), sourceId));&#125; 其中 anim.setOneShot(boolean arg) 表示 ：帧动画是否执行一次 true表示执行一次，false表示循环 二、补间动画 补间动画的分类： 补间动画又可以分为四种形式，分别是 alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。 补间动画实现方式： 利用xml实现 首先在res目录下创建一个anim文件夹，即我们xml实现补间动画都是在res/anim/目录下添加 alpha_anim.xml动画实现 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android"android:duration="1000"android:fromAlpha="1.0"android:interpolator="@android:anim/accelerate_decelerate_interpolator"android:toAlpha="0" /&gt; scale_anim.xml动画实现 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android"android:duration="1000"android:fromXScale="1.0"android:fromYScale="1.0"android:pivotX="50%"android:pivotY="50%"android:toXScale="0.0"android:toYScale="0.0" /&gt; 集合动画 set_anim.xml动画集合 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"android:duration="持续时间"android:interpolator="@[package:]anim/interpolator_resource"android:shareInterpolator="boolean"&gt;&lt;alpha android:fromAlpha="float" android:toAlpha="float" /&gt;&lt;scale android:fromXScale="float" android:fromYScale="float" android:pivotX="float" android:pivotY="float" android:toXScale="float" android:toYScale="float" /&gt;&lt;translate android:fromXDelta="float" android:fromYDelta="float" android:toXDelta="float" android:toYDelta="float" /&gt;&lt;rotate android:fromDegrees="float" android:pivotX="float" android:pivotY="float" android:toDegrees="float" /&gt;&lt;/set&gt; MainActivity代码 123ImageView imageView = (ImageView) findViewById(R.id.iv);Animation animation = AnimationUtils.loadAnimation(this, R.anim.scale_anim);imageView.startAnimation(animation); AnimationUtils是系统实现的动画工具类 补间动画通过代码实现 代码如下： 1234567891011121314151617181920212223242526272829303132public void alpha(View v)&#123;AlphaAnimation anim = new AlphaAnimation(0.0f, 1.0f);anim.setDuration(1000);v.startAnimation(anim);&#125;public void rotate(View v)&#123;RotateAnimation anim = new RotateAnimation(0.0f, -360f, v.getWidth()/2, v.getHeight()/2);anim.setDuration(1000);v.startAnimation(anim);&#125;public void scale(View v)&#123;ScaleAnimation anim = new ScaleAnimation(1.0f, 0.0f, 0.0f, 1.0f, v.getWidth() / 2, v.getHeight() / 2);anim.setDuration(1000);v.startAnimation(anim);&#125;public void translate(View v)&#123;TranslateAnimation anim = new TranslateAnimation(0.0f, 10.0f, 100f, 200f);anim.setDuration(1000);v.startAnimation(anim);&#125;public void set(View v)&#123;AnimationSet anim = new AnimationSet(this, null);AlphaAnimation alpha = new AlphaAnimation(0.0f, 1.0f);RotateAnimation rotate = new RotateAnimation(0.0f, -360f, v.getWidth()/2, v.getHeight()/2);anim.setDuration(1000);anim.addAnimation(alpha);anim.addAnimation(rotate);v.startAnimation(anim);&#125; 三、 Android 属性动画（Property Animation） 属性动画相关的类： ObjectAnimator (动画的执行类) ValueAnimator (动画的执行类) AnimatorSet (用于控制一组动画的执行：线性，一起，每个动画的先后执行等) AnimatorInflater （ 用户加载属性动画的xml文件） TypeEvaluator （类型估值，主要用于设置动画操作属性的值） TimeInterpolator（时间插值） 属性动画与补间动画的区别： 补间动画有一个最大的缺陷，就是它只是改变了View的显示效果而已，并不会真正的改变View的属性。场景：如果要改变view的宽度，补间动画实现不了，而属性动画可以。 ObjectAnimator用法 ObjectAnimator提供了几个方法（ofInt、ofFloat、ofObject…），都是用来设置动画作用的元素、作用的属性、动画开始、结束、以及中间的任意个属性值。 translationX、translationY：这两个属性作为一种增量来控制着View对象从它布局容器的左上角坐标开始的位置。 rotation、rotationX、rotationY：这三个属性控制着View对象围绕它的支点进行2D和3D的旋转。 scaleX和scaleY：这两个属性控制着View对象围绕它的支点进行2D缩放。 pivotX和pivotY：这两个属性控制着View对象的支点位置，围绕这个支点进行旋转和缩放变换处理。默认情况下，该支点的位置就是View对象的中心点。 alpha：它表示View对象的alpha透明度。 x、y：这是两个简单的实用的属性，它描述了View对象在它的容器中最终的位置。 BackgroundColor：改变背景颜色 注意 缩放、反转等都有中心点或者轴，默认中心缩放，和中间对称线为反转线 123ObjectAnimator.ofFloat(imageView,"rotationX",0.0f,360.f,90.0f,360.0f) .setDuration(2000) .start(); PropertyValuesHolder：以先将动画属性和值暂时的存储起来，后一起执行，在有些时候可以使用替换掉AnimatorSet，减少代码量。 123456PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1, 0, 0.5f); PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1, 0, 0.5f); PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1, 0, 0.5f); ObjectAnimator.ofPropertyValuesHolder(imageView,scaleX,scaleY,alpha) .setDuration(2000) .start(); ObjectAnimator简单的用法介绍完毕下面开始介绍ValueAnimator ValueAnimator介绍以及用法 ValueAnimator是整个属性动画中最核心的一个类，前面介绍的ObjectAnimator也是继承自ValueAnimator。通过前面对ObjectAnimator的介绍，我们知道属性动画的实现机制是通过不断的地对View属性进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类负责计算的。 它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮助我们完成从初始值平滑过渡到结束值这样的效果。 ValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。通常情况下，在ValueAnimator的AnimatorUpdateListener中监听数值的变化，从而完成动画的切换。 实现一个计时器效果 1234567891011121314private void startTimeClock() &#123;final ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 60);valueAnimator.setDuration(1000 * 60);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int time = (int) valueAnimator.getAnimatedValue(); Log.e(TAG, "time=" + time); mTextView.setText(time + ""); &#125;&#125;);valueAnimator.start();&#125; 实现一个物体自由落体 12345678910111213141516171819public void verticalRun(View view) &#123; int mHeight = getResources().getDisplayMetrics().heightPixels; ValueAnimator animator = ValueAnimator.ofFloat(0, mHeight - mBlueBall.getHeight()); animator.setTarget(mBlueBall); animator.setDuration(1000) .start(); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Float value = (Float) animation.getAnimatedValue(); Log.e(TAG, "onAnimationUpdate: value = "+value ); mBlueBall.setTranslationY((Float) animation.getAnimatedValue()); &#125; &#125;);&#125; 动画的监听事件 animator.addListener(AnimatorListener、AnimatorUpdateListener 对象) 实现AnimatorLisener对象 123456789101112131415161718192021animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); 实现AnimatorUpdateListener对象 123456animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; &#125; &#125;); 实现AnimatorLisener、AnimatorUpdateListener 区别在于：前面这个监听需要实现所有的方法，而后面这个只需要实现其中一种方法即可。 animator.addUpdateListener(AnimatorUpdateListener) 上面有个计时器的例子，可以通过实现的方法onAnimationUpdate（ValueAnimator animation）拿到相应的对象 AnimatorSet介绍与使用 介绍：动画的集合，在补间动画中也有个一个动画的集合类AnimationSet,所以AnimatorSet同样的效果，可以帮助我们实现组合属性动画的效果。 AnimatorSet这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ObjectAnimator或者ValueAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包含了以下四个方法： after(Animator anim) ： 将现有动画插入到传入的动画之后执行。 after(long delay)：将现有的动画延迟指定的毫秒后执行。 before(Animator anim)：将现有的动画插入到传入的动画之前执行。 with(Animator anim)：将现有的动画和传入的动画同时执行。 例如我们想让一个TextView先从屏幕外移动到屏幕内，然后旋转360度，同时旋转过程中进行淡入淡出的效果，就可以写出如下代码： 12345678910111213141516private void multiAnimator() &#123;// 移动动画ObjectAnimator transAnimator = ObjectAnimator.ofFloat(mTextView, "translationX", -500f, 300f);// 旋转动画ObjectAnimator rotationAnimator = ObjectAnimator.ofFloat(mTextView, "rotation", 0f, 360f);// 淡入淡出ObjectAnimator alphaAnimator = ObjectAnimator.ofFloat(mTextView, "alpha", 1f, 0f, 1f);AnimatorSet animatorSet = new AnimatorSet();animatorSet.play(rotationAnimator).with(alphaAnimator).after(transAnimator);animatorSet.setDuration(5000);animatorSet.setInterpolator(new LinearInterpolator());animatorSet.start();&#125; Animator监听器 一个完整的动画具有start、Repeat、End、Cancel四个过程，Android提供了接口，让我们能够很容易监听到这些事件。示例代码如下： 123456789101112131415161718192021animatorSet.addListener(new Animator.AnimatorListener() &#123;@Overridepublic void onAnimationStart(Animator animation) &#123; Log.e(TAG, "onAnimationStart");&#125;@Overridepublic void onAnimationEnd(Animator animation) &#123; Log.e(TAG, "onAnimationEnd");&#125;@Overridepublic void onAnimationCancel(Animator animation) &#123; Log.e(TAG, "onAnimationCancel");&#125;@Overridepublic void onAnimationRepeat(Animator animation) &#123; Log.e(TAG, "onAnimationRepeat");&#125;&#125;); 使用xml文件创建属性动画 在res下创建一个animator的文件夹，即res/animator/.xml 例如：sacleX.xml 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:propertyName="scaleX" android:valueFrom="1.0" android:valueTo="2.0" android:valueType="floatType" &gt; &lt;/objectAnimator&gt; 使用AnimatorInflater来加载动画的资源文件，然后设置给相应的target即可。 MainActivity.java 代码如下： 12345public void loadXml(View view) &#123;Animator animator = AnimatorInflater.loadAnimator(this, R.animator.scalex);animator.setTarget(mBlueBall);animator.start();&#125; 其它类似一致，下面讲解利用xml实现属性动画集合 animator_set 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:ordering="together" &gt; &lt;objectAnimator android:duration="1000" android:propertyName="scaleX" android:valueFrom="1" android:valueTo="0.5" &gt; &lt;/objectAnimator&gt; &lt;objectAnimator android:duration="1000" android:propertyName="scaleY" android:valueFrom="1" android:valueTo="0.5" &gt; &lt;/objectAnimator&gt; &lt;/set&gt; 使用set标签，有一个orderring属性设置为together,还有另一个值：sequentially（表示一个接一个执行)。 MainActivity.java代码如下 123Animator animator = AnimatorInflater.loadAnimator(this, R.animator.scalex); animator.setTarget(mBlueBall); animator.start(); 代码同上。 布局动画 主要使用LayoutTransition为布局的容器设置动画，当容器中的视图层次发生变化时存在过渡的动画效果。（略） View的anim方法 12345678910111213141516mBlueBall.animate().alpha(0) .y(200) .setDuration(3000) .withStartAction(new Runnable() &#123; @Override public void run() &#123; Log.e(TAG, "run: withStartAction"); &#125; &#125;) .withEndAction(new Runnable() &#123; @Override public void run() &#123; Log.e(TAG, "run: withEndAction"); &#125; &#125;) .start(); 属性动画原理 属性动画要求动画作用的对象提供该属性的get和set方法，属性动画根据你传递的该熟悉的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。如果让属性动画生效，要同时满足两个条件： object必须要提供setXxx方法，如果动画的时候没有传递初始值，那么还要提供getXxx方法，因为系统要去拿xxx属性的初始值（如果这条不满足，程序直接Crash） object的setXxx对属性xxx所做的改变必须能够通过某种方法反映出来，比如会带来ui的改变啥的（如果这条不满足，动画无效果但不会Crash） 属性动画为什么不能改变Button的宽高 因为Button的内部并没有自己的getWith()、setWidth()方法，为什么这样说，button继承至TextView,持有TextView的get、set方法。所以我们对Button做宽高的改变是，没有 效果的。 解决方法 1 ： 用一个类来包装原始对象，间接为其提供get和set方法 包装类如下： 12345678910111213141516171819202122232425public class ViewWrapper &#123;private View mView;public ViewWrapper(View mView) &#123; this.mView = mView;&#125;public void setWidth(int width) &#123; mView.getLayoutParams().width = width; mView.requestLayout();&#125;public int getWidth() &#123; return mView.getLayoutParams().width;&#125;public void setHeight(int height) &#123; mView.getLayoutParams().height = height; mView.requestLayout();&#125;public int getHeight() &#123; return mView.getLayoutParams().height;&#125;&#125; MainActivity.java 代码： 123456ViewWrapper viewWrapper = new ViewWrapper(mBtn);PropertyValuesHolder proW = PropertyValuesHolder.ofInt("width", width, width * 2);PropertyValuesHolder proH = PropertyValuesHolder.ofInt("height", height, height * 3);ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(viewWrapper, proW, proH);objectAnimator.setDuration(3000).start(); 解决方法2： 采用ValueAnimator，监听动画过程，自己实现属性的改变 例子： 12345678910111213141516171819 private void performAnimate(final View mTarget, final int start, final int end) &#123; ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; //持有一个IntEvaluator对象，用来估值使用 private IntEvaluator mEvaluator = new IntEvaluator(); @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //获得当前动画的进度 int value = (Integer) animation.getAnimatedValue(); Log.e(TAG, "onAnimationUpdate: curr value = " + value); float fraction = value / 100f; mTarget.getLayoutParams().width = mEvaluator.evaluate(fraction, start, end); mTarget.requestLayout(); mTarget.invalidate(); &#125; &#125;); valueAnimator.setDuration(3000).start();&#125; 用ValueAnimator来做动画。ValueAnimator并不会实质的做什么。所以需要后面的AnimatorUpdateListener来做一些粗活儿。这里指定的从1到100也没有什么实质的作用。并不是把按钮的宽度从1变到100。后面的代码很清晰的表达了这一点。 据这个fraction的百分比来计算当前时间片对应的按钮宽度是多少。当前宽度 = 初始宽度 + fraction * （结束宽度 - 初始宽度）。 ​]]></content>
      <categories>
        <category>动画</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
</search>
