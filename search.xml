<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[反射笔记]]></title>
    <url>%2F2018%2F04%2F09%2F%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[反射123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346package com.zwang.april;import com.zwang.april.bean.Student;import com.zwang.april.bean.WorkMan;import org.junit.Test;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;/** * ●●● * 反射的概述: * &lt;p&gt; * JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象， * 都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 * 要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象. * &lt;p&gt; * (总结) 反射就是把java类中的各种成分映射成一个个的Java对象 * &lt;p&gt; * ●●● * 深拷贝 与 浅拷贝 : 大部分都是浅拷贝（通过实现Cloneable接口，重写clone()方法，调用super.clone()来实现深拷贝） * 真正的深拷贝：通过实现Serializable 接口并用对象的序列化和反序列化来实现真正的深度克隆做法：（参阅下列的 clone()） * 通过ByteArrayOutputStream ObjectArrayOutputStream write() 再通过ByteArrayInputStream ObjectArrayInputStream read()实现 * &lt;p&gt; * ●●● * 泛型的协变 与 逆变 : 协变---&gt; List&lt;? extends Number&gt; list = new ArrayList&lt;&gt;(); 逆变 ---&gt; List&lt;? super Number&gt; list =new ArrayList&lt;&gt;(); * &lt;p&gt; * 泛型的上边界 与 下边界 : ? extends Number 指定了上边界 ? super Number 指定了下边界 * &lt;p&gt; * description: 练习处 * author: phl * date: 2018-04-09 下午 2:06 * update: * version: 1.0 */public class MainActivityTest &#123; /** * 1 获取类名三种方式： * 1.1 通过对象 getClass() * 1.2 通过对象 .class * 1.3 通过包名全路径 Class.forName(String package) */ @Test public void test() &#123; //1.1 获取类名 (创建一个对象实例，然后通过getClass()方法获取---对象都已经拿到了，反射用处不大) Student stu = new Student(); Class&lt;? extends Student&gt; aClass1 = stu.getClass(); System.out.println(aClass1.getName()); //1.2 获取类名 (通过 .class --- 需要导入包，依赖性较强) Class&lt;Student&gt; aClass2 = Student.class; System.out.println(aClass1 == aClass2); try &#123; //1.3 获取类名（通过包名全路径+Class --- 一个字符串就可以，相对于更加优势） Class&lt;?&gt; aClass3 = Class.forName("com.zwang.april.bean.Student"); System.out.println(aClass1 == aClass3); Class&lt;?&gt; aClass = Class.forName("java.util.ArrayList"); System.out.print(aClass.getName()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 2 通过Class对象获取构造方法，成员变量，成员方法，并访问成员 * &lt;p&gt; * 2.1 通过Class对象获取构造方法 * 批量 * class.getConstructors() 获取该所有public修饰的Constructor * 单个 * class.getConstructor(Class... parameterTypes) 获取指定的public修饰的构造方法 * 批量 * class.getDeclaredConstructors() 获取所有的Constructor * 单个 * class.getDeclaredConstructors(Class... parameterTypes) 获取指定的Constructor */ @Test public void constructor() &#123; try &#123; Class&lt;?&gt; stuClass = Class.forName("com.zwang.april.bean.Student"); Constructor&lt;?&gt;[] pubCons = stuClass.getConstructors(); for (Constructor con : pubCons) &#123; System.out.println(con); &#125; System.out.println("**********************所有构造方法*********************************"); Constructor&lt;?&gt;[] allCons = stuClass.getDeclaredConstructors(); for (Constructor con : allCons) &#123; System.out.println(con); &#125; System.out.println("**********************指定构造方法*********************************"); Constructor&lt;?&gt; constructor = stuClass.getDeclaredConstructor(int.class); System.out.println(constructor); //不能直接访问非public修饰的构造方法、属性或者方法 否则 Framework Method invoke Explosively //暴力访问: setAccessible（true）忽略掉访问修饰符 constructor.setAccessible(true); //Uses the constructor represented by this &#123;@code Constructor&#125; object to //create and initialize a new instance of the constructor's declaring class Object instance = constructor.newInstance(1); System.out.println(instance); &#125; catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; /** * 2.2 访问成员变量并调用 * &lt;p&gt; * 批量 * class.getFields() 访问所有public修饰的字段 * class.getDeclaredFields() 访问所有字段 * &lt;p&gt; * 单个 * class.getField(String name) 访问一个指定public修饰的字段 * class.getDeclaredField(String name) 访问所有的字段 * &lt;p&gt; * 举例：获取某个public修饰的字段 并调用 * (1) Class&lt;?&gt; wClass = Class.forName(); 先获取class对象 * (2) Field f = wClass.getField("name"); 通过getField(String name) 获取public修饰的字段 * (3) Object obj = wClass.getConstructor().newInstance(); 通过构造函数初始化该对象 * (4) f.set(obj,"刘德华"); Field.set(Object obj, Object value); Object ---&gt; 修改字段的对象 value ---&gt; 修改改参数的值(若为private修饰，需要添加访问权限) * (5) WorkMan man = (WorkMan)obj; * (6) 打印man */ @Test public void accessField() &#123; try &#123; Class&lt;?&gt; workClass = Class.forName("com.zwang.april.bean.WorkMan"); System.out.println("****************访问所有public字段****************"); Field[] pubFields = workClass.getFields(); for (Field f : pubFields) &#123; System.out.println(f); &#125; System.out.println("****************访问所有字段（包括private、protect、默认）****************"); Field[] allFields = workClass.getDeclaredFields(); for (Field f : allFields) &#123; System.out.println(f); &#125; Field name = workClass.getDeclaredField("sex"); System.out.println(name); //实例化一个对象 Object obj = workClass.getConstructor().newInstance(); //添加字段访问权限 name.setAccessible(true); //为字段设置值 name.set(obj, '男'); WorkMan workMan = (WorkMan) obj; System.out.println(workMan); &#125; catch (ClassNotFoundException | NoSuchFieldException | IllegalAccessException | InvocationTargetException | InstantiationException | NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125; /** * 2.3 获取成员方法并调用 * 批量 * class.getMethods() * class.getDeclaredMethods() * &lt;p&gt; * 单个 * class.getMethod(String name, Class&lt;?&gt;... parameterTypes) name ---&gt; 方法名 parameterTypes ---&gt;方法中的参数 * class.getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) name ---&gt; 方法名 parameterTypes ---&gt;方法中的参数 * &lt;p&gt; * &lt;p&gt; * 调用方法 * ① Class&lt;?&gt; tClass = Class.forName("com.zwang.april.bean.Teacher"); 获取Class对象 * ② Method method = tClass.getDeclaredMethod("show4",int.class); 获取相应的方法 * ③ Object obj = tClass.getConstructor().newInstance(); 通过构造函数进行实例化，生成Class 对象 * ④ method.setAccessible(true); 私有方法需要添加访问权限 * ⑤ Object objectResult = method.invoke(Object obj, Object... args); obj ---&gt; 实例 ，args ---&gt; 传入相应的参数 * 打印 */ @Test public void accessMethod() &#123; try &#123; Class&lt;?&gt; tClass = Class.forName("com.zwang.april.bean.Teacher"); System.out.println("*****************获取所有public修饰的方法*****************"); Method[] pubMethod = tClass.getMethods(); for (Method m : pubMethod) &#123; System.out.println(m); &#125; System.out.println("*****************获取指定public修饰的方法*****************"); Method show1 = tClass.getMethod("show1", String.class); System.out.println(show1); System.out.println("*****************获取所有方法*****************"); Method[] allMethod = tClass.getDeclaredMethods(); for (Method m : allMethod) &#123; System.out.println(m); &#125; System.out.println("*****************获取指定private修饰的方法*****************"); Method show4 = tClass.getDeclaredMethod("show4", int.class); System.out.println(show4); //调用 Object obj = tClass.getConstructor().newInstance(); //允许访问 show4.setAccessible(true); Object result = show4.invoke(obj, 15); System.out.println(result); &#125; catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException | InstantiationException e) &#123; e.printStackTrace(); &#125; &#125; /** * 2.4 反射main方法 * &lt;p&gt; * ┞ Class&lt;?&gt; mClass = Class.forName("com.zwang.april.bean.StaticMethod"); 获取类名 * ┞ Method mMethod = mClass.getMethod("main", String[].class); 获取main() * ┞ 因为是静态方法，所以不需要对象调用，可以直接传入null值 * ┞ mMethod.invoke(null,new Object[]&#123;new String[]&#123;"1","2","3"&#125;&#125;); * ┞ 亦或者传入class * ┞ mMethod.invoke(mClass,new Object[]&#123;new String[]&#123;"1","2","3"&#125;&#125;); */ @Test public void accessMain() &#123; try &#123; Class&lt;?&gt; mClass = Class.forName("com.zwang.april.bean.StaticMethod"); Method mMethod = mClass.getMethod("main", String[].class);// mMethod.invoke(null, (Object) new String[]&#123;"1","2","3"&#125;); //因为是静态方法，所以不需要对象调用，此处可以传null或者是mClass(通过类去调用) // mMethod.invoke(null,new Object[]&#123;new String[]&#123;"1","2","3"&#125;&#125;); mMethod.invoke(mClass, new Object[]&#123;new String[]&#123;"1", "2", "3"&#125;&#125;); &#125; catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; /** * 3.利用反射 、 越过泛型检查 如下 */ @Test public void otherUse() &#123; ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); strList.add("aaa"); strList.add("bbb"); Class&lt;ArrayList&gt; listClass = ArrayList.class; try &#123; Method addMethod = listClass.getMethod("add", Object.class); addMethod.invoke(strList, 100); for (Object obj : strList) &#123; System.out.println(obj); &#125; &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123; e.printStackTrace(); &#125; System.out.println("*********************第二种方式***********************"); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("aaa"); list.add("bbb"); ArrayList mList = list; mList.add(100); for (Object obj : mList) &#123; System.out.println(obj); &#125; &#125; /** * 深拷贝 * &lt;p&gt; * 通过实现Serializable接口，并用对象的序列化与反序列化实现真正的深拷贝 */ public &lt;T extends Serializable&gt; T clone(T obj) &#123; T cloneObj = null; try &#123; ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(byteOut); objOut.writeObject(obj); objOut.close(); ByteArrayInputStream byteInput = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream objInput = new ObjectInputStream(byteInput); cloneObj = (T) objInput.readObject(); objInput.close(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return cloneObj; &#125; /** * 泛型的协变与逆变 * 定义：（≦ 表示继承关系 例如：String extends Object . f(Object) ---&gt; 有Object对象构造出来的一种类型 例如: Object[] 、List） * 当A ≦ B时,如果有f(A) ≦ f(B),那么f叫做协变； * 当A ≦ B时,如果有f(B) ≦ f(A),那么f叫做逆变； * 如果上面两种关系都不成立则叫做不可变。 * &lt;p&gt; * 现在问题来了：究竟什么时候用extends什么时候用super呢？《Effective Java》给出了答案： * PECS: producer-extends, consumer-super. * java.util.Collections的copy方法(JDK1.7)完美地诠释了PECS： */ @Test public void generic() &#123; Object[] objects = new String[3]; //协变 List&lt;? extends Number&gt; list = new ArrayList&lt;&gt;(); //协变 （extends指定泛型的上边界 super指定泛型的下边界） List&lt;? super Number&gt; list1 = new ArrayList&lt;&gt;(); //逆变 &#125;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>反射笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[官网基础]]></title>
    <url>%2F2018%2F01%2F15%2F%E5%AE%98%E7%BD%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[官网基础定义样式要创建一组样式，请在您的项目的 res/values/ 目录中保存一个 XML 文件。 可任意指定该 XML 文件的名称，但它必须使用 .xml 扩展名，并且必须保存在 res/values/ 文件夹内。 该 XML 文件的根节点必须是 &lt;resources&gt;。 对于您想创建的每个样式，向该文件添加一个 &lt;style&gt; 元素，该元素带有对样式进行唯一标识的 name 属性（该属性为必需属性）。然后为该样式的每个属性添加一个 &lt;item&gt; 元素，该元素带有声明样式属性以及属性值的 name（该属性为必需属性）。 根据样式属性，&lt;item&gt; 的值可以是关键字字符串、十六进制颜色值、对另一资源类型的引用或其他值。以下是一个包含单个样式的示例文件： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;style name="CodeFont" parent="@android:style/TextAppearance.Medium"&gt; &lt;item name="android:layout_width"&gt;fill_parent&lt;/item&gt; &lt;item name="android:layout_height"&gt;wrap_content&lt;/item&gt; &lt;item name="android:textColor"&gt;#00FF00&lt;/item&gt; &lt;item name="android:typeface"&gt;monospace&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; &lt;resources&gt; 元素的每个子项都会在编译时转换成一个应用资源对象，该对象可由 &lt;style&gt; 元素的 name 属性中的值引用。 可从 XML 布局以 @style/CodeFont 形式引用该示例样式（如上文引言中所示）。 &lt;style&gt; 元素中的 parent 属性是可选属性，它指定应作为此样式所继承属性来源的另一样式的资源 ID。 如果愿意，您可在随后替换这些继承的样式属性。 ​ Fragment向应用栏添加项目您的片段可以通过实现 onCreateOptionsMenu() 向 Activity 的选项菜单（并因此向应用栏）贡献菜单项。不过，为了使此方法能够收到调用，您必须在onCreate() 期间调用 setHasOptionsMenu()，以指示片段想要向选项菜单添加菜单项（否则，片段将不会收到对 onCreateOptionsMenu() 的调用）。 您之后从片段添加到选项菜单的任何菜单项都将追加到现有菜单项之后。 选定菜单项时，片段还会收到对 onOptionsItemSelected() 的回调。 您还可以通过调用 registerForContextMenu()，在片段布局中注册一个视图来提供上下文菜单。用户打开上下文菜单时，片段会收到对onCreateContextMenu() 的调用。当用户选择某个菜单项时，片段会收到对 onContextItemSelected() 的调用。 注：尽管您的片段会收到与其添加的每个菜单项对应的菜单项选定回调，但当用户选择菜单项时，Activity 会首先收到相应的回调。 如果 Activity 对菜单项选定回调的实现不会处理选定的菜单项，则系统会将事件传递到片段的回调。 这适用于选项菜单和上下文菜单。 intent12345678910111213141516171819//验证是否存在接收intent的应用PackageManager packageManager = getPackageManager();List activities = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);boolean isIntentSafe = activities.size() &gt; 0;//添加意图选择Intent intent = new Intent(Intent.ACTION_SEND);...// Always use string resources for UI text.// This says something like "Share this photo with"String title = getResources().getString(R.string.chooser_title);// Create intent to show chooserIntent chooser = Intent.createChooser(intent, title);// Verify the intent will resolve to at least one activityif (intent.resolveActivity(getPackageManager()) != null) &#123; startActivity(chooser);&#125; 12345678910111213141516171819202122232425262728&lt;！--隐式启动--&gt;&lt;activity android:name="ShareActivity"&gt;&lt;!-- filter for sending text; accepts SENDTO action with sms URI schemes --&gt;&lt;intent-filter&gt; &lt;action android:name="android.intent.action.SENDTO"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:scheme="sms" /&gt; &lt;data android:scheme="smsto" /&gt;&lt;/intent-filter&gt;&lt;!-- filter for sending text or images; accepts SEND action and text or image data --&gt;&lt;intent-filter&gt; &lt;action android:name="android.intent.action.SEND"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;data android:mimeType="image/*"/&gt; &lt;data android:mimeType="text/plain"/&gt;&lt;/intent-filter&gt;&lt;/activity&gt;// Get the intent that started this activityIntent intent = getIntent();Uri data = intent.getData();// Figure out what to do based on the intent typeif (intent.getType().indexOf("image/") != -1) &#123; // Handle intents with image data ...&#125; else if (intent.getType().equals("text/plain")) &#123; // Handle intents with text ...&#125; 危险权限申请12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Here, thisActivity is the current activityif (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; // Show an expanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission. &#125; else &#123; // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125;//处理回调@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! Do the // contacts-related task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other 'case' lines to check for other // permissions this app might request &#125;&#125; 文件IO12345678910111213141516171819202122232425262728293031323334353637383940//基础写String filename = "myfile";String string = "Hello world!";FileOutputStream outputStream;try &#123; outputStream = openFileOutput(filename, Context.MODE_PRIVATE); outputStream.write(string.getBytes()); outputStream.close();&#125; catch (Exception e) &#123; e.printStackTrace();&#125;//临时文件String fileName = Uri.parse(url).getLastPathSegment();file = File.createTempFile(fileName, null, context.getCacheDir());//判断外部存储是否装载public boolean isExternalStorageWritable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) &#123; return true; &#125; return false;&#125;//判断外部存储是否可读public boolean isExternalStorageReadable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123; return true; &#125; return false;&#125; // 指定文件外部存储目录，可以传null. File file = new File(context.getExternalFilesDir( Environment.DIRECTORY_PICTURES), albumName);//查询存储使用信息getCacheDir().getFreeSpace()getCacheDir().getTotalSpace() room数据库的使用：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//By default, Room creates a column for each field that's defined in the entity. //If an entity has fields that you don't want to persist, you can annotate them using @Ignore. //You must reference the entity class through the entities array in the Database class.@Entityclass User &#123; @PrimaryKey public int id; public String firstName; public String lastName; @Ignore Bitmap picture;&#125;//复合型主键@Entity(primaryKeys = &#123;"firstName", "lastName"&#125;)class User &#123; public String firstName; public String lastName; @Ignore Bitmap picture;&#125;//表重命名，否则就是以类名作为表的名字 （注意：表名不区分大小写）@Entity(primaryKeys = &#123;"firstName", "lastName"&#125;)class User &#123; public String firstName; public String lastName; @Ignore Bitmap picture;&#125;//columnInfo 作用与tableName相似，声明的字段会作为表的列明，通过@columnInfo可修改列名@Entity(tableName = "users")class User &#123; @PrimaryKey public int id; @ColumnInfo(name = "first_name") public String firstName; @ColumnInfo(name = "last_name") public String lastName; @Ignore Bitmap picture;&#125;//定义对象之间的关系（）@Entity(foreignKeys = @ForeignKey(entity = User.class, parentColumns = "id", childColumns = "user_id"))class Book &#123; @PrimaryKey public int bookId; public String title; @ColumnInfo(name = "user_id") public int userId;&#125;//使用注解@Embedded创建嵌套对象 （User表中包含Address的street，state,city,post_code）class Address &#123; public String street; public String state; public String city; @ColumnInfo(name = "post_code") public int postCode;&#125;@Entityclass User &#123; @PrimaryKey public int id; public String firstName; @Embedded public Address address;&#125; 相机要求相关硬件12345&lt;manifest ... &gt; &lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt; ...&lt;/manifest&gt; 简单拍照/获取缩略图123456789101112131415161718static final int REQUEST_IMAGE_CAPTURE = 1;//拍照private void dispatchTakePictureIntent() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE); &#125;&#125;//获取缩略图@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get("data"); mImageView.setImageBitmap(imageBitmap); &#125;&#125; 获取唯一文件1234567891011121314151617String mCurrentPhotoPath;private File createImageFile() throws IOException &#123; // Create an image file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()); String imageFileName = "JPEG_" + timeStamp + "_"; File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES); File image = File.createTempFile( imageFileName, /* prefix */ ".jpg", /* suffix */ storageDir /* directory */ ); // Save a file: path for use with ACTION_VIEW intents mCurrentPhotoPath = image.getAbsolutePath(); return image;&#125; 拍照/原图123456789101112131415161718192021222324static final int REQUEST_TAKE_PHOTO = 1;private void dispatchTakePictureIntent() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); // Ensure that there's a camera activity to handle the intent if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; // Create the File where the photo should go File photoFile = null; try &#123; photoFile = createImageFile(); &#125; catch (IOException ex) &#123; // Error occurred while creating the File ... &#125; // Continue only if the File was successfully created if (photoFile != null) &#123; Uri photoURI = FileProvider.getUriForFile(this, "com.example.android.fileprovider", photoFile); takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI); startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO); &#125; &#125;&#125; 通知图库更新12345678//可以让其他应用访问private void galleryAddPic() &#123; Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); File f = new File(mCurrentPhotoPath); Uri contentUri = Uri.fromFile(f); mediaScanIntent.setData(contentUri); this.sendBroadcast(mediaScanIntent);&#125; 尺寸压缩1234567891011121314151617181920212223private void setPic() &#123; // Get the dimensions of the View int targetW = mImageView.getWidth(); int targetH = mImageView.getHeight(); // Get the dimensions of the bitmap BitmapFactory.Options bmOptions = new BitmapFactory.Options(); bmOptions.inJustDecodeBounds = true; BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); int photoW = bmOptions.outWidth; int photoH = bmOptions.outHeight; // Determine how much to scale down the image int scaleFactor = Math.min(photoW/targetW, photoH/targetH); // Decode the image file into a Bitmap sized to fill the View bmOptions.inJustDecodeBounds = false; bmOptions.inSampleSize = scaleFactor; bmOptions.inPurgeable = true; Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); mImageView.setImageBitmap(bitmap);&#125; 调用相机录制视频123456789101112131415161718//添加 &lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt;static final int REQUEST_VIDEO_CAPTURE = 1;private void dispatchTakeVideoIntent() &#123; Intent takeVideoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE); if (takeVideoIntent.resolveActivity(getPackageManager()) != null) &#123; startActivityForResult(takeVideoIntent, REQUEST_VIDEO_CAPTURE); &#125;&#125;//通过使用videoView播放@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent intent) &#123; if (requestCode == REQUEST_VIDEO_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Uri videoUri = intent.getData(); mVideoView.setVideoURI(videoUri); &#125;&#125; Sence布局生成Sence12345678910Scene mAScene;Scene mAnotherScene;// Create the scene root for the scenes in this appmSceneRoot = (ViewGroup) findViewById(R.id.scene_root);// Create the scenesmAScene = Scene.getSceneForLayout(mSceneRoot, R.layout.a_scene, this);mAnotherScene = Scene.getSceneForLayout(mSceneRoot, R.layout.another_scene, this); 代码创建Sence1234567891011Scene mScene;// Obtain the scene root elementmSceneRoot = (ViewGroup) mSomeLayoutElement;// Obtain the view hierarchy to add as a child of// the scene root when this scene is enteredmViewHierarchy = (ViewGroup) someOtherLayoutElement;// Create a scenemScene = new Scene(mSceneRoot, mViewHierarchy); Transition的创建12345678910//通过布局的方式创建//res/transition/fade_transition.xml&lt;fade xmlns:android="http://schemas.android.com/apk/res/android" /&gt;Transition mFadeTransition = TransitionInflater.from(this). inflateTransition(R.transition.fade_transition);//通过代码的方式创建Transition [AutoTransition,Fade,ChangeBounds]Transition mFadeTransition = new Fade(); Transition应用有场景的转换12//通常用于不同的视图切换TransitionManager.go(mEndingScene, mFadeTransition); Transition应用无场景的转换(TransitionManager.beginDelayedTransition(rootview,flag) 用于记录视图层次结构)123456789101112// Get the root view and create a transitionmRootView = (ViewGroup) findViewById(R.id.mainLayout);mFade = new Fade(IN);// Start recording changes to the view hierarchyTransitionManager.beginDelayedTransition(mRootView, mFade);// Add the new TextView to the view hierarchymRootView.addView(mLabelText);// When the system redraws the screen to show this update,// the framework will animate the addition as a fade in PageTransformer缩放效果（https://developer.android.google.cn/training/animation/anim_page_transformer_zoomout.mp4） 1234567891011121314151617181920212223242526272829303132333435363738public class ZoomOutPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 1) &#123; // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 透明效果（https://developer.android.google.cn/training/animation/anim_page_transformer_depth.mp4） 123456789101112131415161718192021222324252627282930313233343536public class DepthPageTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) &#123; int pageWidth = view.getWidth(); if (position &lt; -1) &#123; // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); &#125; else if (position &lt;= 0) &#123; // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); &#125; else if (position &lt;= 1) &#123; // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); &#125; else &#123; // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); &#125; &#125;&#125; 查看大图(https://developer.android.google.cn/training/animation/anim_zoom.mp4)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137private void zoomImageFromThumb(final View thumbView, int imageResId) &#123; // If there's an animation in progress, cancel it // immediately and proceed with this one. if (mCurrentAnimator != null) &#123; mCurrentAnimator.cancel(); &#125; // Load the high-resolution "zoomed-in" image. final ImageView expandedImageView = (ImageView) findViewById( R.id.expanded_image); expandedImageView.setImageResource(imageResId); // Calculate the starting and ending bounds for the zoomed-in image. // This step involves lots of math. Yay, math. final Rect startBounds = new Rect(); final Rect finalBounds = new Rect(); final Point globalOffset = new Point(); // The start bounds are the global visible rectangle of the thumbnail, // and the final bounds are the global visible rectangle of the container // view. Also set the container view's offset as the origin for the // bounds, since that's the origin for the positioning animation // properties (X, Y). thumbView.getGlobalVisibleRect(startBounds); findViewById(R.id.container) .getGlobalVisibleRect(finalBounds, globalOffset); startBounds.offset(-globalOffset.x, -globalOffset.y); finalBounds.offset(-globalOffset.x, -globalOffset.y); // Adjust the start bounds to be the same aspect ratio as the final // bounds using the "center crop" technique. This prevents undesirable // stretching during the animation. Also calculate the start scaling // factor (the end scaling factor is always 1.0). float startScale; if ((float) finalBounds.width() / finalBounds.height() &gt; (float) startBounds.width() / startBounds.height()) &#123; // Extend start bounds horizontally startScale = (float) startBounds.height() / finalBounds.height(); float startWidth = startScale * finalBounds.width(); float deltaWidth = (startWidth - startBounds.width()) / 2; startBounds.left -= deltaWidth; startBounds.right += deltaWidth; &#125; else &#123; // Extend start bounds vertically startScale = (float) startBounds.width() / finalBounds.width(); float startHeight = startScale * finalBounds.height(); float deltaHeight = (startHeight - startBounds.height()) / 2; startBounds.top -= deltaHeight; startBounds.bottom += deltaHeight; &#125; // Hide the thumbnail and show the zoomed-in view. When the animation // begins, it will position the zoomed-in view in the place of the // thumbnail. thumbView.setAlpha(0f); expandedImageView.setVisibility(View.VISIBLE); // Set the pivot point for SCALE_X and SCALE_Y transformations // to the top-left corner of the zoomed-in view (the default // is the center of the view). expandedImageView.setPivotX(0f); expandedImageView.setPivotY(0f); // Construct and run the parallel animation of the four translation and // scale properties (X, Y, SCALE_X, and SCALE_Y). AnimatorSet set = new AnimatorSet(); set .play(ObjectAnimator.ofFloat(expandedImageView, View.X, startBounds.left, finalBounds.left)) .with(ObjectAnimator.ofFloat(expandedImageView, View.Y, startBounds.top, finalBounds.top)) .with(ObjectAnimator.ofFloat(expandedImageView, View.SCALE_X, startScale, 1f)).with(ObjectAnimator.ofFloat(expandedImageView, View.SCALE_Y, startScale, 1f)); set.setDuration(mShortAnimationDuration); set.setInterpolator(new DecelerateInterpolator()); set.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; mCurrentAnimator = null; &#125; @Override public void onAnimationCancel(Animator animation) &#123; mCurrentAnimator = null; &#125; &#125;); set.start(); mCurrentAnimator = set; // Upon clicking the zoomed-in image, it should zoom back down // to the original bounds and show the thumbnail instead of // the expanded image. final float startScaleFinal = startScale; expandedImageView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; if (mCurrentAnimator != null) &#123; mCurrentAnimator.cancel(); &#125; // Animate the four positioning/sizing properties in parallel, // back to their original values. AnimatorSet set = new AnimatorSet(); set.play(ObjectAnimator .ofFloat(expandedImageView, View.X, startBounds.left)) .with(ObjectAnimator .ofFloat(expandedImageView, View.Y,startBounds.top)) .with(ObjectAnimator .ofFloat(expandedImageView, View.SCALE_X, startScaleFinal)) .with(ObjectAnimator .ofFloat(expandedImageView, View.SCALE_Y, startScaleFinal)); set.setDuration(mShortAnimationDuration); set.setInterpolator(new DecelerateInterpolator()); set.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; thumbView.setAlpha(1f); expandedImageView.setVisibility(View.GONE); mCurrentAnimator = null; &#125; @Override public void onAnimationCancel(Animator animation) &#123; thumbView.setAlpha(1f); expandedImageView.setVisibility(View.GONE); mCurrentAnimator = null; &#125; &#125;); set.start(); mCurrentAnimator = set; &#125; &#125;);&#125; 更改布局动画（添加、删除、更新）12345&lt;!--在相应的布局中添加animateLayoutChanges = true--&gt;&lt;LinearLayout android:id="@+id/container" android:animateLayoutChanges="true" .../&gt; 尺寸限定符：res/layout/main.xml，单窗格（默认）布局： res/layout-large/main.xml，双窗格布局： res/layout-sw600dp/main.xml，双窗格布局：（最小宽度大于或等于 600dp 的设备将选择 layout-sw600dp/main.xml） NinePatch(.9图制作详情) 边框沿线的黑色像素。顶部和左侧边框上的黑色像素指示可以拉伸图像的位置，右侧和底部边框上的黑色像素则指示应该放置内容的位置。 DP xhdpi：2.0 hdpi：1.5 mdpi：1.0（基准） ldpi：0.75 ConstraintLayout 官网有详细介绍 https://developer.android.google.cn/training/constraint-layout/index.html Toolbar12345678&lt;android.support.v7.widget.Toolbar android:id="@+id/my_toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="?attr/colorPrimary" android:elevation="4dp" 官方推荐 android:theme="@style/ThemeOverlay.AppCompat.ActionBar" app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/&gt; SearchView 可以作为menu使用，也可以作为一个控件使用 12345&lt;item android:id="@+id/action_search" android:title="@string/action_search" android:icon="@drawable/ic_search" app:showAsAction="ifRoom|collapseActionView" app:actionViewClass="android.support.v7.widget.SearchView" /&gt; 1234567891011121314151617@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main_activity_actions, menu); MenuItem searchItem = menu.findItem(R.id.action_search); SearchView searchView = (SearchView) MenuItemCompat.getActionView(searchItem); // Configure the search info and add any event listeners... return super.onCreateOptionsMenu(menu);&#125;//可以自定义各种状态下的iconactionView.setOnCloseListener();//监听打开关闭actionView.setOnSuggestionListener();//推荐列表 actionView.setOnQueryTextListener()//类似文本间监听 返回false自动收起键盘 snackbar1234Snackbar mySnackbar = Snackbar.make(findViewById(R.id.myCoordinatorLayout), R.string.email_archived,Snackbar.LENGTH_SHORT);mySnackbar.setAction(R.string.undo_string, new MyUndoListener());mySnackbar.show(); 管理系统界面123456789// This example uses decor view, but you can use any visible view.View decorView = getActivity().getWindow().getDecorView();int uiOptions = View.SYSTEM_UI_FLAG_LOW_PROFILE;decorView.setSystemUiVisibility(uiOptions);View decorView = getActivity().getWindow().getDecorView();// Calling setSystemUiVisibility() with a value of 0 clears// all flags.decorView.setSystemUiVisibility(0); 隐藏状态栏当失去焦点时会无效，比如触摸其他，后台重新进入界面 12345678910111213141516171819202122232425262728293031323334353637383940View decorView = getWindow().getDecorView();// Hide the status bar.int uiOptions = View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibility(uiOptions);// Remember that you should never show the action bar if the// status bar is hidden, so hide that too if necessary.ActionBar actionBar = getActionBar();actionBar.hide();//配合setFitsSystemWindows()View.SYSTEM_UI_FLAG_FULLSCREEN | //隐藏状态栏View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN| //内容填充状态栏View.SYSTEM_UI_FLAG_LAYOUT_STABLE| //保持布局稳定View.SYSTEM_UI_FLAG_HIDE_NAVIGATION|//隐藏导航虚拟按键View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION|//内容填充导航虚拟按键View.SYSTEM_UI_FLAG_IMMERSIVE|//沉浸式全屏View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY//沉浸式全屏 划出状态栏，状态栏会自动消失//处理状态栏被显示的问题getWindow().getDecorView().setOnSystemUiVisibilityChangeListeneronWindowFocusChanged() mDecorView.setOnSystemUiVisibilityChangeListener(new View.OnSystemUiVisibilityChangeListener() &#123; @Override public void onSystemUiVisibilityChange(int visibility) &#123; // Note that system bars will only be "visible" if none of the // LOW_PROFILE, HIDE_NAVIGATION, or FULLSCREEN flags are set. if ((visibility &amp; View.SYSTEM_UI_FLAG_FULLSCREEN) == 0) &#123; // TODO: The system bars are visible. Make any desired // adjustments to your UI, such as showing the action bar or // other navigational controls. &#125; else &#123; // TODO: The system bars are NOT visible. Make any desired // adjustments to your UI, such as hiding the action bar or // other navigational controls. &#125; &#125; &#125;); Material Design定制状态栏 12//当recycleview宽高不变时增删改查时提高性能mRecyclerView.setHasFixedSize(true); 阴影 12345Z = elevation + translationZ//自定义阴影轮廓，因为实际轮廓都是正方形扩展 ViewOutlineProvider 类别。替代 getOutline() 方法。利用 View.setOutlineProvider() 方法向您的视图指定新的轮廓提供程序。 定制动画触摸反馈（水波纹）12345//矩形边框水波纹android:background="?android:attr/selectableItemBackground"//无边框限制水波纹android:background="?android:attr/selectableItemBackgroundBorderless" 自定义水波纹12345678910111213141516171819/*** Creates a new ripple drawable with the specified ripple color and * optional content and mask drawables. * 通过指定波纹的颜色、操作内容、蒙板边界 创建新的ripple drawable 。 * @param color The ripple color 波纹颜色 * @param content The content drawable, may be &#123;@code null&#125; 指定content drawable * @param mask The mask drawable, may be &#123;@code null&#125; 蒙板边界 、为null时，无边界 */public RippleDrawable(@NonNull ColorStateList color, @Nullable Drawable content, @Nullable Drawable mask) &#123; ...&#125;RippleDrawable rd = new RippleDrawable( ColorStateList.valueOf( getResources().getColor(R.color.bg_gray)), drawable, getShape() );tvColor.setBackgroundDrawable(rd); 揭露动画123// create the animator for this view (the start radius is zero)Animator anim = ViewAnimationUtils.createCircularReveal(myView, cx, cy, 0, finalRadius); ​]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>官网基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画]]></title>
    <url>%2F2018%2F01%2F07%2F%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[动画笔记 作者：彭欢亮 时间：2018/1/7 星期日 上午 10:10:10 Android 动画的分类 ： 一、帧动画 实现帧动画的两种方式 利用xml形式实现 在drawable目录下创建一个animation-list xml 文件， 1234567891011121314 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;item android:drawable="@mipmap/ic_setup" android:duration="500" /&gt;&lt;item android:drawable="@mipmap/ic_should_get" android:duration="500" /&gt;&lt;item android:drawable="@mipmap/ic_should_pay" android:duration="500" /&gt;&lt;/animation-list&gt; MainActivity代码 123456ImageView imageView = (ImageView) findViewById(R.id.iv);imageView.setImageResource(R.drawable.animation_z);AnimationDrawable animation = (AnimationDrawable) imageView.getDrawable();// animation.start();//将animationDrawable设置为imageView的背景imageView.setBackground(animation); 帧动画实现的第二种方式，利用代码实现 （使用场景：帧动画图片太多的情况下，建议使用此方法，不用在xml文件中一个个添加） MainActivity 123456789101112ImageView imageView = (ImageView) findViewById(R.id.iv)AnimationDrawable anim = new AnimationDrawable();anim.addFrame(bit2dra(R.mipmap.ic_setup), 200);anim.addFrame(bit2dra(R.mipmap.ic_should_get), 200);anim.addFrame(bit2dra(R.mipmap.ic_should_pay), 200);anim.setOneShot(false);imageView.setImageDrawable(anim);//bit2dra 将bitmap转换为drawable对象private Drawable bit2dra(int sourceId) &#123; return new BitmapDrawable(getResources(), BitmapFactory.decodeResource(getResources(), sourceId));&#125; 其中 anim.setOneShot(boolean arg) 表示 ：帧动画是否执行一次 true表示执行一次，false表示循环 二、补间动画 补间动画的分类： 补间动画又可以分为四种形式，分别是 alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。 补间动画实现方式： 利用xml实现 首先在res目录下创建一个anim文件夹，即我们xml实现补间动画都是在res/anim/目录下添加 alpha_anim.xml动画实现 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android"android:duration="1000"android:fromAlpha="1.0"android:interpolator="@android:anim/accelerate_decelerate_interpolator"android:toAlpha="0" /&gt; scale_anim.xml动画实现 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android"android:duration="1000"android:fromXScale="1.0"android:fromYScale="1.0"android:pivotX="50%"android:pivotY="50%"android:toXScale="0.0"android:toYScale="0.0" /&gt; 集合动画 set_anim.xml动画集合 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"android:duration="持续时间"android:interpolator="@[package:]anim/interpolator_resource"android:shareInterpolator="boolean"&gt;&lt;alpha android:fromAlpha="float" android:toAlpha="float" /&gt;&lt;scale android:fromXScale="float" android:fromYScale="float" android:pivotX="float" android:pivotY="float" android:toXScale="float" android:toYScale="float" /&gt;&lt;translate android:fromXDelta="float" android:fromYDelta="float" android:toXDelta="float" android:toYDelta="float" /&gt;&lt;rotate android:fromDegrees="float" android:pivotX="float" android:pivotY="float" android:toDegrees="float" /&gt;&lt;/set&gt; MainActivity代码 123ImageView imageView = (ImageView) findViewById(R.id.iv);Animation animation = AnimationUtils.loadAnimation(this, R.anim.scale_anim);imageView.startAnimation(animation); AnimationUtils是系统实现的动画工具类 补间动画通过代码实现 代码如下： 1234567891011121314151617181920212223242526272829303132public void alpha(View v)&#123;AlphaAnimation anim = new AlphaAnimation(0.0f, 1.0f);anim.setDuration(1000);v.startAnimation(anim);&#125;public void rotate(View v)&#123;RotateAnimation anim = new RotateAnimation(0.0f, -360f, v.getWidth()/2, v.getHeight()/2);anim.setDuration(1000);v.startAnimation(anim);&#125;public void scale(View v)&#123;ScaleAnimation anim = new ScaleAnimation(1.0f, 0.0f, 0.0f, 1.0f, v.getWidth() / 2, v.getHeight() / 2);anim.setDuration(1000);v.startAnimation(anim);&#125;public void translate(View v)&#123;TranslateAnimation anim = new TranslateAnimation(0.0f, 10.0f, 100f, 200f);anim.setDuration(1000);v.startAnimation(anim);&#125;public void set(View v)&#123;AnimationSet anim = new AnimationSet(this, null);AlphaAnimation alpha = new AlphaAnimation(0.0f, 1.0f);RotateAnimation rotate = new RotateAnimation(0.0f, -360f, v.getWidth()/2, v.getHeight()/2);anim.setDuration(1000);anim.addAnimation(alpha);anim.addAnimation(rotate);v.startAnimation(anim);&#125; 三、 Android 属性动画（Property Animation） 属性动画相关的类： ObjectAnimator (动画的执行类) ValueAnimator (动画的执行类) AnimatorSet (用于控制一组动画的执行：线性，一起，每个动画的先后执行等) AnimatorInflater （ 用户加载属性动画的xml文件） TypeEvaluator （类型估值，主要用于设置动画操作属性的值） TimeInterpolator（时间插值） 属性动画与补间动画的区别： 补间动画有一个最大的缺陷，就是它只是改变了View的显示效果而已，并不会真正的改变View的属性。场景：如果要改变view的宽度，补间动画实现不了，而属性动画可以。 ObjectAnimator用法 ObjectAnimator提供了几个方法（ofInt、ofFloat、ofObject…），都是用来设置动画作用的元素、作用的属性、动画开始、结束、以及中间的任意个属性值。 translationX、translationY：这两个属性作为一种增量来控制着View对象从它布局容器的左上角坐标开始的位置。 rotation、rotationX、rotationY：这三个属性控制着View对象围绕它的支点进行2D和3D的旋转。 scaleX和scaleY：这两个属性控制着View对象围绕它的支点进行2D缩放。 pivotX和pivotY：这两个属性控制着View对象的支点位置，围绕这个支点进行旋转和缩放变换处理。默认情况下，该支点的位置就是View对象的中心点。 alpha：它表示View对象的alpha透明度。 x、y：这是两个简单的实用的属性，它描述了View对象在它的容器中最终的位置。 BackgroundColor：改变背景颜色 注意 缩放、反转等都有中心点或者轴，默认中心缩放，和中间对称线为反转线 123ObjectAnimator.ofFloat(imageView,"rotationX",0.0f,360.f,90.0f,360.0f) .setDuration(2000) .start(); PropertyValuesHolder：以先将动画属性和值暂时的存储起来，后一起执行，在有些时候可以使用替换掉AnimatorSet，减少代码量。 123456PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1, 0, 0.5f); PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1, 0, 0.5f); PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1, 0, 0.5f); ObjectAnimator.ofPropertyValuesHolder(imageView,scaleX,scaleY,alpha) .setDuration(2000) .start(); ObjectAnimator简单的用法介绍完毕下面开始介绍ValueAnimator ValueAnimator介绍以及用法 ValueAnimator是整个属性动画中最核心的一个类，前面介绍的ObjectAnimator也是继承自ValueAnimator。通过前面对ObjectAnimator的介绍，我们知道属性动画的实现机制是通过不断的地对View属性进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类负责计算的。 它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮助我们完成从初始值平滑过渡到结束值这样的效果。 ValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。通常情况下，在ValueAnimator的AnimatorUpdateListener中监听数值的变化，从而完成动画的切换。 实现一个计时器效果 1234567891011121314private void startTimeClock() &#123;final ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 60);valueAnimator.setDuration(1000 * 60);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int time = (int) valueAnimator.getAnimatedValue(); Log.e(TAG, "time=" + time); mTextView.setText(time + ""); &#125;&#125;);valueAnimator.start();&#125; 实现一个物体自由落体 12345678910111213141516171819public void verticalRun(View view) &#123; int mHeight = getResources().getDisplayMetrics().heightPixels; ValueAnimator animator = ValueAnimator.ofFloat(0, mHeight - mBlueBall.getHeight()); animator.setTarget(mBlueBall); animator.setDuration(1000) .start(); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Float value = (Float) animation.getAnimatedValue(); Log.e(TAG, "onAnimationUpdate: value = "+value ); mBlueBall.setTranslationY((Float) animation.getAnimatedValue()); &#125; &#125;);&#125; 动画的监听事件 animator.addListener(AnimatorListener、AnimatorUpdateListener 对象) 实现AnimatorLisener对象 123456789101112131415161718192021animator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;); 实现AnimatorUpdateListener对象 123456animator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; &#125; &#125;); 实现AnimatorLisener、AnimatorUpdateListener 区别在于：前面这个监听需要实现所有的方法，而后面这个只需要实现其中一种方法即可。 animator.addUpdateListener(AnimatorUpdateListener) 上面有个计时器的例子，可以通过实现的方法onAnimationUpdate（ValueAnimator animation）拿到相应的对象 AnimatorSet介绍与使用 介绍：动画的集合，在补间动画中也有个一个动画的集合类AnimationSet,所以AnimatorSet同样的效果，可以帮助我们实现组合属性动画的效果。 AnimatorSet这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ObjectAnimator或者ValueAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包含了以下四个方法： after(Animator anim) ： 将现有动画插入到传入的动画之后执行。 after(long delay)：将现有的动画延迟指定的毫秒后执行。 before(Animator anim)：将现有的动画插入到传入的动画之前执行。 with(Animator anim)：将现有的动画和传入的动画同时执行。 例如我们想让一个TextView先从屏幕外移动到屏幕内，然后旋转360度，同时旋转过程中进行淡入淡出的效果，就可以写出如下代码： 12345678910111213141516private void multiAnimator() &#123;// 移动动画ObjectAnimator transAnimator = ObjectAnimator.ofFloat(mTextView, "translationX", -500f, 300f);// 旋转动画ObjectAnimator rotationAnimator = ObjectAnimator.ofFloat(mTextView, "rotation", 0f, 360f);// 淡入淡出ObjectAnimator alphaAnimator = ObjectAnimator.ofFloat(mTextView, "alpha", 1f, 0f, 1f);AnimatorSet animatorSet = new AnimatorSet();animatorSet.play(rotationAnimator).with(alphaAnimator).after(transAnimator);animatorSet.setDuration(5000);animatorSet.setInterpolator(new LinearInterpolator());animatorSet.start();&#125; Animator监听器 一个完整的动画具有start、Repeat、End、Cancel四个过程，Android提供了接口，让我们能够很容易监听到这些事件。示例代码如下： 123456789101112131415161718192021animatorSet.addListener(new Animator.AnimatorListener() &#123;@Overridepublic void onAnimationStart(Animator animation) &#123; Log.e(TAG, "onAnimationStart");&#125;@Overridepublic void onAnimationEnd(Animator animation) &#123; Log.e(TAG, "onAnimationEnd");&#125;@Overridepublic void onAnimationCancel(Animator animation) &#123; Log.e(TAG, "onAnimationCancel");&#125;@Overridepublic void onAnimationRepeat(Animator animation) &#123; Log.e(TAG, "onAnimationRepeat");&#125;&#125;); 使用xml文件创建属性动画 在res下创建一个animator的文件夹，即res/animator/.xml 例如：sacleX.xml 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;objectAnimator xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:propertyName="scaleX" android:valueFrom="1.0" android:valueTo="2.0" android:valueType="floatType" &gt; &lt;/objectAnimator&gt; 使用AnimatorInflater来加载动画的资源文件，然后设置给相应的target即可。 MainActivity.java 代码如下： 12345public void loadXml(View view) &#123;Animator animator = AnimatorInflater.loadAnimator(this, R.animator.scalex);animator.setTarget(mBlueBall);animator.start();&#125; 其它类似一致，下面讲解利用xml实现属性动画集合 animator_set 1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:ordering="together" &gt; &lt;objectAnimator android:duration="1000" android:propertyName="scaleX" android:valueFrom="1" android:valueTo="0.5" &gt; &lt;/objectAnimator&gt; &lt;objectAnimator android:duration="1000" android:propertyName="scaleY" android:valueFrom="1" android:valueTo="0.5" &gt; &lt;/objectAnimator&gt; &lt;/set&gt; 使用set标签，有一个orderring属性设置为together,还有另一个值：sequentially（表示一个接一个执行)。 MainActivity.java代码如下 123Animator animator = AnimatorInflater.loadAnimator(this, R.animator.scalex); animator.setTarget(mBlueBall); animator.start(); 代码同上。 布局动画 主要使用LayoutTransition为布局的容器设置动画，当容器中的视图层次发生变化时存在过渡的动画效果。（略） View的anim方法 12345678910111213141516mBlueBall.animate().alpha(0) .y(200) .setDuration(3000) .withStartAction(new Runnable() &#123; @Override public void run() &#123; Log.e(TAG, "run: withStartAction"); &#125; &#125;) .withEndAction(new Runnable() &#123; @Override public void run() &#123; Log.e(TAG, "run: withEndAction"); &#125; &#125;) .start(); 属性动画原理 属性动画要求动画作用的对象提供该属性的get和set方法，属性动画根据你传递的该熟悉的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。如果让属性动画生效，要同时满足两个条件： object必须要提供setXxx方法，如果动画的时候没有传递初始值，那么还要提供getXxx方法，因为系统要去拿xxx属性的初始值（如果这条不满足，程序直接Crash） object的setXxx对属性xxx所做的改变必须能够通过某种方法反映出来，比如会带来ui的改变啥的（如果这条不满足，动画无效果但不会Crash） 属性动画为什么不能改变Button的宽高 因为Button的内部并没有自己的getWith()、setWidth()方法，为什么这样说，button继承至TextView,持有TextView的get、set方法。所以我们对Button做宽高的改变是，没有 效果的。 解决方法 1 ： 用一个类来包装原始对象，间接为其提供get和set方法 包装类如下： 12345678910111213141516171819202122232425public class ViewWrapper &#123;private View mView;public ViewWrapper(View mView) &#123; this.mView = mView;&#125;public void setWidth(int width) &#123; mView.getLayoutParams().width = width; mView.requestLayout();&#125;public int getWidth() &#123; return mView.getLayoutParams().width;&#125;public void setHeight(int height) &#123; mView.getLayoutParams().height = height; mView.requestLayout();&#125;public int getHeight() &#123; return mView.getLayoutParams().height;&#125;&#125; MainActivity.java 代码： 123456ViewWrapper viewWrapper = new ViewWrapper(mBtn);PropertyValuesHolder proW = PropertyValuesHolder.ofInt("width", width, width * 2);PropertyValuesHolder proH = PropertyValuesHolder.ofInt("height", height, height * 3);ObjectAnimator objectAnimator = ObjectAnimator.ofPropertyValuesHolder(viewWrapper, proW, proH);objectAnimator.setDuration(3000).start(); 解决方法2： 采用ValueAnimator，监听动画过程，自己实现属性的改变 例子： 12345678910111213141516171819 private void performAnimate(final View mTarget, final int start, final int end) &#123; ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; //持有一个IntEvaluator对象，用来估值使用 private IntEvaluator mEvaluator = new IntEvaluator(); @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //获得当前动画的进度 int value = (Integer) animation.getAnimatedValue(); Log.e(TAG, "onAnimationUpdate: curr value = " + value); float fraction = value / 100f; mTarget.getLayoutParams().width = mEvaluator.evaluate(fraction, start, end); mTarget.requestLayout(); mTarget.invalidate(); &#125; &#125;); valueAnimator.setDuration(3000).start();&#125; 用ValueAnimator来做动画。ValueAnimator并不会实质的做什么。所以需要后面的AnimatorUpdateListener来做一些粗活儿。这里指定的从1到100也没有什么实质的作用。并不是把按钮的宽度从1变到100。后面的代码很清晰的表达了这一点。 据这个fraction的百分比来计算当前时间片对应的按钮宽度是多少。当前宽度 = 初始宽度 + fraction * （结束宽度 - 初始宽度）。 ​]]></content>
      <categories>
        <category>动画</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
</search>
